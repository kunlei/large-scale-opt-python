[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Hands-on Large Scale Optimization in Python",
    "section": "",
    "text": "Preface\nDecomposition algorithms are powerful techniques in solving various large-scale optimization problems. This book tries to explain the theories behind various decomposition algorithms and illustrate their usage via a number of classical optimization problems.\nOut of the algorithms examined in this book, column generation is my favorite algorithm. I have used it to solve various large-scale optimization problem in my research and industry projects. Often times, the theories are straightforward for most Operations Research (OR) students, but the biggest challenge lies in being able to recognize the opportunity to apply one of the decomposition algorithms.\nAs I apply these algorithms time and again in my career, this book aims to serve as my personal reference to save time and solve problems more efficiently.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "introduction.html",
    "href": "introduction.html",
    "title": "1  Introduction",
    "section": "",
    "text": "Introduction.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "benders-theory.html",
    "href": "benders-theory.html",
    "title": "2  Benders Decomposition Theories",
    "section": "",
    "text": "2.1 The Decomposition Logic\nTo explain the workings of Benders decomposition, let us look at the standard form of linear programming problems that involve two vector variables, \\(\\mathbf{x}\\) and \\(\\mathbf{y}\\). Let \\(p\\) and \\(q\\) indicate the dimensions of \\(\\mathbf{x}\\) and \\(\\mathbf{y}\\), respectively. Below is the original problem (P) we intend to solve.\n\\[\\begin{align}\n\\text{min.} &\\quad \\mathbf{c}^T \\mathbf{x} + \\mathbf{f}^T \\mathbf{y} \\\\\n\\text{s.t.} &\\quad \\mathbf{A} \\mathbf{x} + \\mathbf{B} \\mathbf{y} = \\mathbf{b} \\\\\n&\\quad \\mathbf{x} \\geq 0, \\mathbf{y} \\geq 0\n\\end{align}\\]\nIn this formulation, \\(\\mathbf{c}\\) and \\(\\mathbf{f}\\) in the objective function represent the cost coefficients associated with decision variables \\(\\mathbf{x}\\) and \\(\\mathbf{y}\\), respectively. Both of them are column vectors of corresponding dimensions. In the constraints, matrix \\(\\mathbf{A}\\) is of dimension \\(m \\times p\\), and matrix \\(\\mathbf{B}\\) is of dimension \\(m \\times q\\). \\(\\mathbf{b}\\) is a column vector of dimension \\(m\\).\nSuppose the variable \\(\\mathbf{y}\\) is a complicating variable in the sense that the resulting problem is substantially easier to solve if the value of \\(\\mathbf{y}\\) is fixed. In this case, we could rewrite problem \\(\\mathbf{P}\\) as the following form:\n\\[\\begin{align}\n\\text{min.} &\\quad \\mathbf{f}^T \\mathbf{y} + g(\\mathbf{y}) \\\\\n\\text{s.t.} &\\quad \\mathbf{y} \\geq 0\n\\end{align}\\]\nwhere \\(g(\\mathbf{y})\\) is a function of \\(\\mathbf{y}\\) and is defined as the subproblem \\(\\mathbf{SP}\\) of the form below:\n\\[\\begin{align}\n    \\text{min.} &\\quad \\mathbf{c}^T \\mathbf{x} \\\\\n    \\text{s.t.} &\\quad \\mathbf{A} \\mathbf{x}  = \\mathbf{b} - \\mathbf{B} \\mathbf{y} \\label{bd-cons1} \\\\\n    &\\quad \\mathbf{x} \\geq 0\n\\end{align}\\]\nNote that the \\(\\mathbf{y}\\) in constraint \\(\\eqref{bd-cons1}\\) takes on some known values when the problem is solved and the only decision variable in the above formulation is \\(\\mathbf{x}\\). The dual problem of \\(\\mathbf{SP}\\), \\(\\mathbf{DSP}\\), is given below.\n\\[\\begin{align}\n    \\text{max.} &\\quad (\\mathbf{b} - \\mathbf{B} \\mathbf{y})^{T} \\mathbf{u} \\\\\n    \\text{s.t.} &\\quad \\mathbf{A}^T \\mathbf{u} \\leq \\mathbf{c} \\label{bd-cons2} \\\\\n    &\\quad \\mathbf{u}\\  \\text{unrestricted}\n\\end{align}\\]\nA key characteristic of the above \\(\\mathbf{DSP}\\) is that its solution space does not depend on the value of \\(\\mathbf{y}\\), which only affects the objective function. According to the Minkowski’s representation theorem, any \\(\\bar{\\mathbf{u}}\\) satisfying the constraints \\(\\eqref{bd-cons2}\\) can be expressed as\n\\[\\begin{align}\n\\bar{\\mathbf{u}} = \\sum_{j \\in \\mathbf{J}} \\lambda_j \\mathbf{u}_{j}^{point} + \\sum_{k \\in \\mathbf{K}} \\mu_k \\mathbf{u}_k^{ray}\n\\end{align}\\]\nwhere \\(\\mathbf{u}_j^{point}\\) and \\(\\mathbf{u}_k^{ray}\\) represent an extreme point and extreme ray, respectively. In addition, \\(\\lambda_j \\geq 0\\) for all \\(j \\in \\mathbf{J}\\) and \\(\\sum_{j \\in \\mathbf{J}}\\lambda_j = 1\\), and \\(\\mu_k \\geq 0\\) for all \\(k \\in \\mathbf{K}\\). It follows that the \\(\\mathbf{DSP}\\) is equivalent to\n\\[\\begin{align}\n\\text{max.} &\\quad (\\mathbf{b} - \\mathbf{B} \\mathbf{y})^{T} (\\sum_{j \\in \\mathbf{J}} \\lambda_j \\mathbf{u}_{j}^{point} + \\sum_{k \\in \\mathbf{K}} \\mu_k \\mathbf{u}_k^{ray}) \\\\\n\\text{s.t.} &\\quad \\sum_{j \\in \\mathbf{J}}\\lambda_j = 1 \\\\\n&\\quad \\lambda_j \\geq 0, \\ \\forall j \\in \\mathbf{J} \\\\\n&\\quad \\mu_k \\geq 0, \\ \\forall k \\in \\mathbf{K}\n\\end{align}\\]\nWe can therefore conclude that\nBased on this idea, the \\(\\mathbf{DSP}\\) can be reformulated as follows:\n\\[\\begin{align}\n\\text{min.} &\\quad g \\\\\n\\text{s.t.} &\\quad (\\mathbf{b} - \\mathbf{B} \\mathbf{y})^{T} \\mathbf{u}_k^{ray} \\leq 0, \\ \\forall j \\in \\mathbf{J} \\label{bd-feas} \\\\\n&\\quad (\\mathbf{b} - \\mathbf{B} \\mathbf{y})^{T} \\mathbf{u}_j^{point} \\leq g, \\ \\forall k \\in \\mathbf{K} \\label{bd-opt} \\\\\n&\\quad j \\in \\mathbf{J}, k \\in \\mathbf{K}\n\\end{align}\\]\nConstraints \\(\\eqref{bd-feas}\\) are called Benders feasibility cuts, while constraints \\(\\eqref{bd-opt}\\) are called Benders optimality cuts. Now we are ready to define the Benders Master Problem (\\(\\mathbf{BMP}\\)) as follows:\n\\[\\begin{align}\n    \\text{min.} &\\quad \\mathbf{f}^T \\mathbf{y} + g \\\\\n    \\text{s.t.} &\\quad (\\mathbf{b} - \\mathbf{B} \\mathbf{y})^{T} \\mathbf{u}_k^{ray} \\leq 0, \\ \\forall j \\in \\mathbf{J} \\\\\n    &\\quad (\\mathbf{b} - \\mathbf{B} \\mathbf{y})^{T} \\mathbf{u}_j^{point} \\leq g, \\ \\forall k \\in \\mathbf{K} \\\\\n    &\\quad j \\in \\mathbf{J}, k \\in \\mathbf{K}, \\mathbf{y} \\geq 0\n\\end{align}\\]\nTypically \\(J\\) and \\(K\\) are too large to enumerate upfront and we have to work with subsets of them, denoted by \\(J_s\\) and \\(K_s\\), respectively. Hence we have the following Restricted Benders Master Problem (\\(\\mathbf{RBMP}\\)):\n\\[\\begin{align}\n    \\text{min.} &\\quad \\mathbf{f}^T \\mathbf{y} + g \\\\\n    \\text{s.t.} &\\quad (\\mathbf{b} - \\mathbf{B} \\mathbf{y})^{T} \\mathbf{u}_k^{ray} \\leq 0, \\ \\forall j \\in \\mathbf{J}_s \\\\\n    &\\quad (\\mathbf{b} - \\mathbf{B} \\mathbf{y})^{T} \\mathbf{u}_j^{point} \\leq g, \\ \\forall k \\in \\mathbf{K}_s \\\\\n    &\\quad j \\in \\mathbf{J}, k \\in \\mathbf{K}, \\mathbf{y} \\geq 0\n\\end{align}\\]\nflowchart LR\n   A[Start] --&gt; B{Is}\n    B --&gt;|Yes| C[OK]\n    C --&gt; D[Rethink]\n    D --&gt; B\n    B ----&gt;|No| E[End]\n\n\n\n\nFigure 2.1: Benders decomposition workflow",
    "crumbs": [
      "Benders Decomposition",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Benders Decomposition Theories</span>"
    ]
  },
  {
    "objectID": "benders-theory.html#the-decomposition-logic",
    "href": "benders-theory.html#the-decomposition-logic",
    "title": "2  Benders Decomposition Theories",
    "section": "",
    "text": "The \\(\\mathbf{DSP}\\) becomes unbounded if any \\(\\mathbf{u}_k^{ray}\\) exists such that \\((\\mathbf{b} - \\mathbf{B} \\mathbf{y})^{T} \\mathbf{u}_k^{ray} &gt; 0\\). Note that an unbounded \\(\\mathbf{DSP}\\) implies an infeasible \\(\\mathbf{SP}\\) and to prevent this from happening, we have to ensure that \\((\\mathbf{b} - \\mathbf{B} \\mathbf{y})^{T} \\mathbf{u}_k^{ray} \\leq 0\\) for all \\(k \\in \\mathbf{K}\\).\nIf an optimal solution to \\(\\mathbf{DSP}\\) exists, it must occur at one of the extreme points. Let \\(g\\) denote the optimal objective value, it follows that \\((\\mathbf{b} - \\mathbf{B} \\mathbf{y})^{T} \\mathbf{u}_j^{point} \\leq g\\) for all \\(j \\in \\mathbf{J}\\).",
    "crumbs": [
      "Benders Decomposition",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Benders Decomposition Theories</span>"
    ]
  },
  {
    "objectID": "benders-linear-prog.html",
    "href": "benders-linear-prog.html",
    "title": "3  Solving Linear Programming Problems with Benders Decomposition",
    "section": "",
    "text": "In this chapter, we use Benders decomposition to solve several linear programming (LP) problems in order to demonstrate the decomposition logic, especially how the restricted Benders master problem interacts with the subproblem in an iterative approach to reach final optimality. Most linear programs could be solved efficiently nowadays by either open source or commercial solvers without resorting to any decomposition approaches. However, by working through the example problems in the following sections, we aim to showcase the implementation details when applying Benders decomposition algorithm on real problems, which helps solidify our understanding of Benders decomposition. Hopefully, by the end of this chapter, we will build up enough intuition as well as hands-on experience such that we are ready to tackle most involved problems in the following chapters.\nIn the following sections, we employ several steps to illustrate the problem solving process of Benders decomposition.\n\nWe will first create two linear programming solvers based on Gurobi and SCIP that can solve any linear programs defined in the standard form. They are used in later section to validate the correctness of the solutions produced by Benders decomposition.\nNext, we use a specific linear program and give the corresponding RBMP and DSP to prepare for the implementations.\nThen, we will solve the example linear program step by step by examining the outputs of the RBMP and DSP to decided the next set of actions.\nFuthermore, a holistic Benders decomposition implementation is then developed to solve the example linear program.\nFollowing the previous step, a more generic Benders decomposition implementation is created.\nThen, we will examine an alternative implementation using Gurobi callback functions.\nWe will also provide an implementation based on SCIP.\nIn the final section, we will do several benchmarking testing.\n\n\n3.0.1 LP solvers based on Gurobi and SCIP\nWe aim to use Benders decomposition to solve several linear programming problems in the following sections. To do that, we intentionally decompose the LP problem under consideration into two sets, one set of complicating variables and the other set containing the remaining variables. In order to validate the correctness of the results obtained by Benders decomposition, we implement two additional ways of solving the target linear programming problems directly. The first option is based on the Gurobi API in python and the other is based on the open source solve SCIP. The two implementations defined here assume the LP problems under consideration follow the below standard form:\n\\[\\begin{align}\n    \\text{min.} &\\quad \\mathbf{c}^T \\mathbf{x} \\\\\n    \\text{s.t.} &\\quad \\mathbf{A} \\mathbf{x} = \\mathbf{b} \\\\\n    &\\quad \\mathbf{x} \\geq 0\n\\end{align}\\]\nListing 3.1 defines a solver for LP problems using Gurobi. It takes three constructor parameters:\n\nobj_coeff: this corresponds to the objective coefficients \\(\\mathbf{c}\\).\nconstr_mat: this refers to the constraint matrix \\(\\mathbf{A}\\).\nrhs: this is the right-hand side \\(\\mathbf{b}\\).\n\nInside the constructor __init__(), a solver environment _env is first created and then used to initialize a model object _model. The input parameters are then used to create decision variables _vars, constraints _constrs and objective function respectively. The optimize() function simply solves the problem and shows the solving status. Finally, the clean_up() function frees up the computing resources.\n\n\n\n\nListing 3.1: A LP solver based on Gurobi\n\n\nimport gurobipy as gp\nfrom gurobipy import GRB\nimport numpy as np\n\nclass LpSolverGurobi:\n    \n    def __init__(self, obj_coeff, constr_mat, rhs, verbose=False):\n        # initialize environment and model\n        self._env = gp.Env('GurobiEnv', empty=True)\n        # self._env.setParam('LogToConsole', 1 if verbose else 0)\n        self._env.setParam('OutputFlag', 1 if verbose else 0)\n        self._env.start()\n        self._model = gp.Model(env=self._env, name='GurobiLpSolver')\n        \n        # prepare data\n        self._obj_coeff = obj_coeff\n        # print(self._obj_coeff)\n        self._constr_mat = constr_mat\n        # print(self._constr_mat)\n        self._rhs = rhs\n        self._num_vars = len(self._obj_coeff)\n        self._num_constrs = len(self._rhs)\n        \n        # create decision variables\n        self._vars = self._model.addMVar(self._num_vars, \n                                         vtype=GRB.CONTINUOUS, \n                                         lb=0)\n        \n        # create constraints\n        self._constrs = self._model.addConstr(\n            self._constr_mat@self._vars == self._rhs\n        )\n        \n        # create objective\n        self._model.setObjective(self._obj_coeff@self._vars, \n                                 GRB.MINIMIZE)\n    \n    def optimize(self, verbose=False):\n        self._model.optimize()\n        if self._model.status == GRB.OPTIMAL:\n            print(f'Optimal solution found!')\n            print(f'Optimal objective = {self._model.objVal:.2f}')\n        elif self._model.status == GRB.UNBOUNDED:\n            print(f'Model is unbounded!')\n        elif self._model.status == GRB.INFEASIBLE:\n            print(f'Model is infeasible!')\n        else:\n            print(f'Unknown error occurred!')\n            \n    def save_model(self, filename):\n        self._model.write(filename)\n    \n    def clean_up(self):\n        self._model.dispose()\n        self._env.dispose()\n\n\n\n\nListing 3.2 presents an LP solver implementation in class LpSolverSCIP using SCIP. The constructor requires the same of parameters as defined in LpSolverGurobi. The model building process is similar with minor changes when required to create decision variables, constraints and the objective function.\n\n\n\n\nListing 3.2: A LP solver based on SCIP\n\n\nimport pyscipopt as scip\nfrom pyscipopt import SCIP_PARAMSETTING\n\nclass LpSolverSCIP:\n    \n    def __init__(self, obj_coeff, constr_mat, rhs, verbose=False):\n        self._model = scip.Model('LpModel')\n        if not verbose:\n            self._model.hideOutput()\n    \n        # create variables\n        self._vars = {\n            i: self._model.addVar(lb=0, vtype='C')\n            for i in range(len(obj_coeff))\n        }\n        \n        # create constraints\n        for c in range(len(rhs)):\n            expr = [\n                constr_mat[c][j] * self._vars.get(j)\n                for j in range(len(obj_coeff))\n            ]\n            self._model.addCons(scip.quicksum(expr) == rhs[c])\n            \n        # create objective\n        obj_expr = [\n            obj_coeff[i] * self._vars.get(i)\n            for i in range(len(obj_coeff))\n        ]\n        self._model.setObjective(scip.quicksum(obj_expr), \"minimize\")\n    \n    def optimize(self):\n        self._model.optimize()\n        status = self._model.getStatus()\n        if status == \"optimal\":\n            print(f'Optimal solution found!')\n            print(f'Optimal objective = {self._model.getObjVal():.2f}')\n        elif status == \"unbounded\":\n            print(f'Model is unbounded!')\n        elif status == \"infeasible\":\n            print(f'Model is infeasible!')\n        else:\n            print(f'Unknown error occurred!')\n\n\n\n\nListing 3.3 generates a LP problem with 20 decision variables and 5 constraints.\n\n\n\n\nListing 3.3: A randomly generated LP problem\n\n\nimport numpy as np\n\nnp.random.seed(42)\nc = np.random.randint(1, 6, size=20)\nA = np.random.randint(-10, 12, size=(5, 20))\nb = np.random.randint(20, 100, size=5)\n\n\n\n\nListing 3.4 solves the generated LP using LpSolverGurobi and the solver output shows that an optimal solution was found with objective value of 36.90.\n\n\n\n\nListing 3.4: Solving the generated LP with Gurobi\n\n\nlpsolver_gurobi = LpSolverGurobi(obj_coeff=c, constr_mat=A, rhs=b)\nlpsolver_gurobi.optimize()\n\n\n\n\nOptimal solution found!\nOptimal objective = 36.90\n\n\nListing 3.5 solves the same LP problem using SCIP and not surprisingly, the same optimal objective value was found. This is not exciting, as it only indicates that the two solvers agree on the optimal solution on such a small LP problem as expected. However, they will become more useful in the following sections when we use them to validate our Benders decomposition results.\n\n\n\n\nListing 3.5: Solving the generated LP with SCIP\n\n\nlpsolver_scip = LpSolverSCIP(obj_coeff=c, constr_mat=A, rhs=b)\nlpsolver_scip.optimize()\n\n\n\n\nOptimal solution found!\nOptimal objective = 36.90\n\n\n\n\n3.0.2 A serious LP problem that cannot wait to be decomposed!\nWith the validation tools available for use, we are ready to solve some serious LP problems using Benders decomposition! What we have below is a LP problem with five decision variables, three of which are denoted by \\(\\mathbf{x} = (x_1, x_2, x_3)\\) and the remaining two variables are denoted by \\(\\mathbf{y} = (y_1, y_2)\\). We assume that \\(\\mathbf{y}\\) are the complicating variables.\n\\[\\begin{align*}\n    \\text{min.} &\\quad 8x_1 + 12x_2 +10x_3 + 15y_1 + 18y_2 \\\\\n    \\text{s.t.} &\\quad 2x_1 + 3x_2 + 2x_3 + 4y_1 + 5y_2 = 300 \\\\\n    &\\quad 4x_1 + 2x_2 + 3x_3 + 2y_1 + 3y_2 = 220 \\\\\n    &\\quad x_i \\geq 0, \\ \\forall i = 1, \\cdots, 3 \\\\\n    &\\quad y_i \\geq 0, \\ \\forall j = 1, 2\n\\end{align*}\\]\nAccording to the standard LP form presented in the previous section, \\(\\mathbf{c}^T = (8, 12, 10)\\), \\(\\mathbf{f}^T = (15, 18)\\) and \\(\\mathbf{b}^T = (300, 220)\\). In addition,\n\\[\\begin{equation*}\n\\mathbf{A} =\n\\begin{bmatrix}\n    2 & 3 & 2 \\\\\n    4 & 2 & 3 \\\\\n\\end{bmatrix}\n\\qquad\n\\mathbf{B} =\n\\begin{bmatrix}\n    4 & 5 \\\\\n    2 & 3 \\\\\n\\end{bmatrix}\n\\end{equation*}\\]\nListing 3.6 solves the LP problem using the two solvers define above. Both solvers confirm the optimal objective value is 1091.43. With this information in mind, we will apply Benders decomposition to see if the same optimal solution could be identified or not.\n\n\n\n\nListing 3.6: Solve the LP problem with Gurobi and SCIP\n\n\nc = np.array([8, 12, 10])\nf = np.array([15, 18])\nobj_coeff = np.concatenate([c, f])\n\nA = np.array([[2, 3, 2],\n     [4, 2, 3]])\nB = np.array([[4, 5],\n     [2, 3]])\nconstr_mat = np.concatenate([A, B], axis=1)\n\nrhs = np.array([300, 220])\n\nlpsolver_gurobi = LpSolverGurobi(obj_coeff, constr_mat, rhs, verbose=False)\nlpsolver_gurobi.optimize()\n# Optimal objective = 1091.43\n\nlpsolver_scip = LpSolverSCIP(obj_coeff, constr_mat, rhs, verbose=False)\nlpsolver_scip.optimize()\n# Optimal objective = 1091.43\n\n\n\n\nOptimal solution found!\nOptimal objective = 1091.43\nOptimal solution found!\nOptimal objective = 1091.43\n\n\n\n\n3.0.3 Benders decomposition formulations\nWith \\(\\mathbf{y}\\) being the complicating variable, we state the Benders subproblem (SP) below for the \\(\\mathbf{y}\\) assuming fixed values \\(\\mathbf{\\bar{y}} = (\\bar{y_1}, \\bar{y_2})\\):\n\\[\\begin{align*}\n    \\text{min.} &\\quad 8x_1 + 12x_2 +10x_3 \\\\\n    \\text{s.t.} &\\quad 2x_1 + 3x_2 + 2x_3 = 300 - 4\\bar{y_1} - 5\\bar{y_2} \\\\\n    &\\quad 4x_1 + 2x_2 + 3x_3 = 220 - 2\\bar{y_1} - 3\\bar{y_2} \\\\\n    &\\quad x_i \\geq 0, \\ \\forall i = 1, \\cdots, 3\n\\end{align*}\\]\nWe define the dual variable \\(\\mathbf{u} = (u_1, u_2)\\) to associate with the constraints in the (SP). The dual subproblem (DSP) could then be stated as follows:\n\\[\\begin{align*}\n    \\text{max.} &\\quad (300 - 4\\bar{y_1} - 5\\bar{y_2}) u_1 + (220 - 2\\bar{y_1} - 3\\bar{y_2}) u_2 \\\\\n    \\text{s.t.} &\\quad 2u_1 + 4u_2 \\leq 8\\\\\n    &\\quad 3u_1 + 2u_2 \\leq 12 \\\\\n    &\\quad 2u_1 + 3u_2 \\leq 10 \\\\\n    &\\quad u_1, u_2\\  \\text{unrestricted}\n\\end{align*}\\]\nThe (RBMP) can be stated as below. Note that \\(\\mathbf{u} = (0, 0)\\) is a feasible solution to (DSP) and the corresponding objective value is 0, which is the reason we restrict the variable \\(g\\) to be nonnegative.\n\\[\\begin{align*}\n    \\text{min.} &\\quad 15 y_1 + 18 y_2 + g \\\\\n    \\text{s.t.} &\\quad  y_1, y_2 \\geq 0 \\\\\n    &\\quad g \\geq 0\n\\end{align*}\\]\n\n\n3.0.4 Benders decomposition step by step\nBenders decomposition defines a problem solving process in which the restricted Benders master problem and the dual subproblem interact iteratively to identify the optimal solution or conclude infeasibility/unboundedness. To facilitate our understanding of the process, we demonstrate in this section the workings of Benders decomposition by solving the target LP problem step by step.\nListing 3.7 shows the codes that initialize the lower bound lb, upper bound ub and threshold value eps. Furthermore, the restricted Benders master problem rbmp is created with three variables and a minimizing objective function. Note that no constraints are yet included in the model at this moment.\n\n\n\n\nListing 3.7: Gurobi solver setup and restricted master problem initialization\n\n\nimport numpy as np\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# initialize lower/upper bounds and threshold value\nlb = -GRB.INFINITY\nub = GRB.INFINITY\neps = 1.0e-5\n\n# create restricted Benders master problem\nenv = gp.Env('benders', empty=True)\nenv.setParam('OutputFlag', 0)\nenv.start()\nrbmp = gp.Model(env=env, name='RBMP')\n\n# create decision variables\ny1 = rbmp.addVar(vtype=GRB.CONTINUOUS, lb=0, name='y1')\ny2 = rbmp.addVar(vtype=GRB.CONTINUOUS, lb=0, name='y2')\ng = rbmp.addVar(vtype=GRB.CONTINUOUS, lb=0, name='g')\n\n# create objective\nrbmp.setObjective(15*y1 + 18*y2 + g, GRB.MINIMIZE)\n\n\n\n\nListing 3.8 initializes the Benders subproblem with two decision variables and three constraints.\n\n\n\n\nListing 3.8: Dual subproblem initialization\n\n\n# create dual subproblem\ndsp = gp.Model(env=env, name='DSP')\n\n# create decision variables\nu1 = dsp.addVar(vtype=GRB.CONTINUOUS,\n                lb=-GRB.INFINITY,\n                ub=GRB.INFINITY,\n                name='u1')\nu2 = dsp.addVar(vtype=GRB.CONTINUOUS,\n                lb=-GRB.INFINITY,\n                ub=GRB.INFINITY,\n                name='u2')\n\n# create objective function\ndsp.setObjective(300*u1 + 220*u2)\n\n# create constraints\ndsp.addConstr(2*u1 + 4*u2 &lt;= 8, name='c1')\ndsp.addConstr(3*u1 + 2*u2 &lt;= 12, name='c2')\ndsp.addConstr(2*u1 + 3*u2 &lt;= 10, name='c3')\n\ndsp.update()\n\n\n\n\nIn Listing 3.9, we solve the (RBMP) for the first time. It has an optimal solution with \\((\\bar{y_1}, \\bar{y_2}, \\bar{g}) = (0, 0, 0)\\) and optimal objective value of 0. This is expected as all the variables assume their minimal possible values in order to minimize the objective function. This objective value also serves as the new lower bound.\n\n\n\n\nListing 3.9: Iteration 1 - solving the restricted Benders master problem\n\n\nrbmp.optimize()\n\nif rbmp.status == GRB.OPTIMAL:\n    print(f'Optimal solution found! Objective value = {rbmp.objVal:.2f}')\n    \n    y1_opt, y2_opt, g_opt = y1.X, y2.X, g.X\n    lb = np.max([lb, rbmp.objVal])\n    \n    print(f'(y1, y2, g) = ({y1_opt:.2f}, {y2_opt:.2f}, {g_opt:.2f})')\n    print(f'lb={lb}, ub={ub}')\nelif rbmp.status == GRB.INFEASIBLE:\n    print(f'original problem is infeasible!')\n\n\n\n\nOptimal solution found! Objective value = 0.00\n(y1, y2, g) = (0.00, 0.00, 0.00)\nlb=0.0, ub=1e+100\n\n\nGiven that \\((\\bar{y_1}, \\bar{y_2}, \\bar{g}) = (0, 0, 0)\\), we now feed the values of \\(\\bar{y_1}\\) and \\(\\bar{y_2}\\) into the Benders dual subproblem (DSP) by updating its objective function, as shown in Listing 3.10:\n\n\n\n\nListing 3.10: Iteration 1 - solving the dual subproblem\n\n\n# update objective function\ndsp.setObjective((300-4*y1_opt-5*y2_opt)*u1 + \n                 (220-2*y1_opt-3*y2_opt)*u2, \n                 GRB.MAXIMIZE)\ndsp.update()\ndsp.optimize()\n\nif dsp.status == GRB.OPTIMAL:\n    u1_opt, u2_opt = u1.X, u2.X\n    \n    print(f'Optimal objective = {dsp.objVal:.2f}')\n    print(f'(u1, u2) = ({u1_opt:.2f}, {u2_opt:.2f})')\n    ub = np.min([ub, 15*y1_opt + 18*y2_opt + dsp.objVal])\n    print(f'lb={lb}, ub={ub}')\n\n\n\n\nOptimal objective = 1200.00\n(u1, u2) = (4.00, 0.00)\nlb=0.0, ub=1200.0\n\n\nWe see that the dual subproblem has an optimal solution. The upper bound ub is also updated. Since the optimal objective value of the subproblem turns out to be 1200 and is greater than \\(\\bar{g} = 0\\), which implies that an optimality cut is needed to make sure that the variable \\(g\\) in the restricted Benders master problem reflects this newly obtained information from the subproblem.\nIn Listing 3.11, the new optimality cut is added to the (RBMP), which is then solved to optimality.\n\n\n\n\nListing 3.11: Iteration 2 - solving the restricted Benders master problem\n\n\n# add optimality cut\nrbmp.addConstr((300-4*y1-5*y2)*u1_opt \n               + (220-2*y1-3*y2)*u2_opt &lt;= g, \n               name='c1')\nrbmp.update()\nrbmp.optimize()\n\nif rbmp.status == GRB.OPTIMAL:\n    print(f'Optimal solution found! Objective value = {rbmp.objVal:.2f}')\n    \n    y1_opt, y2_opt, g_opt = y1.X, y2.X, g.X\n    lb = np.max([lb, rbmp.objVal])\n    \n    print(f'(y1, y2, g) = ({y1_opt:.2f}, {y2_opt:.2f}, {g_opt:.2f})')\n    print(f'lb={lb}, ub={ub}')\nelif rbmp.status == GRB.INFEASIBLE:\n    print(f'original problem is infeasible!')\n\n\n\n\nOptimal solution found! Objective value = 1080.00\n(y1, y2, g) = (0.00, 60.00, 0.00)\nlb=1080.0, ub=1200.0\n\n\nArmed with the optimal solution \\((\\bar{y_1}, \\bar{y_2}, \\bar{g}) = (0, 60, 0)\\), Listing 3.12 updates the objective function of the (DSP) and obtains its optimal solution.\n\n\n\n\nListing 3.12: Iteration 2 - solving the dual subproblem\n\n\n# update objective function\ndsp.setObjective((300-4*y1_opt-5*y2_opt)*u1 \n                 + (220-2*y1_opt-3*y2_opt)*u2, \n                 GRB.MAXIMIZE)\ndsp.update()\ndsp.optimize()\n\nif dsp.status == GRB.OPTIMAL:\n    u1_opt, u2_opt = u1.X, u2.X\n    \n    print(f'Optimal objective = {dsp.objVal:.2f}')\n    print(f'(u1, u2) = ({u1_opt:.2f}, {u2_opt:.2f})')\n    ub = np.min([ub, 15*y1_opt + 18*y2_opt + dsp.objVal])\n    print(f'lb={lb}, ub={ub:.2f}')\nelif dsp.Status == GRB.UNBOUNDED:\n    print(f'DSP is unbounded!')\n    u1_ray = u1.UnbdRay\n    u2_ray = u2.UnbdRay\n    print(f'retrieve extreme ray (u1, u2) = ({u1_ray}, {u2_ray})')\nelse:\n    print(f'DSP solve error')\n\n\n\n\nDSP is unbounded!\nretrieve extreme ray (u1, u2) = (-2.0, 1.0)\n\n\nSince the dual subproblem is unbounded, a feasibility cut is further needed. In Listing 3.13, we add the new cut and solve the restricted Benders master problem again.\n\n\n\n\nListing 3.13: Iteration 3 - solving the restricted Benders master problem\n\n\n# add optimality cut\nrbmp.addConstr((300-4*y1-5*y2)*u1_ray\n               + (220-2*y1-3*y2)*u2_ray &lt;= 0, \n               name='c2')\nrbmp.update()\nrbmp.optimize()\n\nif rbmp.status == GRB.OPTIMAL:\n    print(f'Optimal solution found! Objective value = {rbmp.objVal:.2f}')\n    \n    y1_opt, y2_opt, g_opt = y1.X, y2.X, g.X\n    lb = np.max([lb, rbmp.objVal])\n    \n    print(f'(y1, y2, g) = ({y1_opt:.2f}, {y2_opt:.2f}, {g_opt:.2f})')\n    print(f'lb={lb:.2f}, ub={ub:.2f}')\nelif rbmp.status == GRB.INFEASIBLE:\n    print(f'original problem is infeasible!')\n\n\n\n\nOptimal solution found! Objective value = 1091.43\n(y1, y2, g) = (0.00, 54.29, 114.29)\nlb=1091.43, ub=1200.00\n\n\nNote that a new lower bound is obtained after solving the master problem. Since there is still a large gap between the lower bound and upper bound, we continue solving the subproblem in Listing 3.14.\n\n\n\n\nListing 3.14: Iteration 3 - solving the dual subproblem\n\n\n# update objective function\ndsp.setObjective((300-4*y1_opt-5*y2_opt)*u1 \n                 + (220-2*y1_opt-3*y2_opt)*u2, \n                 GRB.MAXIMIZE)\ndsp.update()\ndsp.optimize()\n\nif dsp.status == GRB.OPTIMAL:\n    u1_opt, u2_opt = u1.X, u2.X\n    \n    print(f'Optimal objective = {dsp.objVal:.2f}')\n    print(f'(u1, u2) = ({u1_opt:.2f}, {u2_opt:.2f})')\n    ub = np.min([ub, 15*y1_opt + 18*y2_opt + dsp.objVal])\n    print(f'lb={lb:.2f}, ub={ub:.2f}')\n\n\n\n\nOptimal objective = 114.29\n(u1, u2) = (4.00, 0.00)\nlb=1091.43, ub=1091.43\n\n\nNow that the difference between lb and ub is less than the preset threshold eps, we conclude that an optimal solution is reached and the computation resources are freed up.\n\n# release resources\nrbmp.dispose()\ndsp.dispose()\nenv.dispose()\n\n\n\n3.0.5 Benders decomposition automated\nIt typically takes Benders decomposition many iterations to reach optimality or conclude infeasibility/unboundedness. In this section, we put everything we have learned from the manual approach above into an automatic workflow.\nListing 3.15 defines an Enum class that specifies four possible optimization statuses. The meanings of these statuses are self-explanatory from their corresponding names and further explanations are omitted here.\n\n\n\n\nListing 3.15: Optimization status\n\n\nimport gurobipy as gp\nfrom gurobipy import GRB\nimport numpy as np\nfrom enum import Enum\n\nclass OptStatus(Enum):\n    OPTIMAL = 0\n    UNBOUNDED = 1\n    INFEASIBLE = 2\n    ERROR = 3\n\n\n\n\nListing 3.16 defines a ManualBendersMasterSolver class that models the (RBMP). Its constructor contains the variable and objective function definitions. The ability to take in either feasibility or optimality cuts is implemented in separate functions add_feasibility_cut() and add_optimality_cut(), respectively. The solve() function is responsible for optimizing the model and retrieve the optimal solution if any.\n\n\n\n\nListing 3.16: Restricted Benders master model\n\n\nclass ManualBendersMasterSolver:\n    \n    def __init__(self, env):\n        self._model = gp.Model(env=env, name='RBMP')\n        \n        # create decision variables\n        self._y1 = self._model.addVar(vtype=GRB.CONTINUOUS, \n                                      lb=0, name='y1')\n        self._y2 = self._model.addVar(vtype=GRB.CONTINUOUS, \n                                      lb=0, name='y2')\n        self._g = self._model.addVar(vtype=GRB.CONTINUOUS, \n                                     lb=0, name='g')\n\n        # create objective\n        self._model.setObjective(15*self._y1+18*self._y2+self._g, \n                                 GRB.MINIMIZE)\n        \n        self._opt_obj = None\n        self._opt_y1 = None\n        self._opt_y2 = None\n        self._opt_g = None\n        \n    def solve(self) -&gt; OptStatus:\n        print('-' * 50)\n        print(f'Start solving master problem.')\n        self._model.optimize()\n        \n        opt_status = None\n        if self._model.status == GRB.OPTIMAL:\n            opt_status = OptStatus.OPTIMAL\n            self._opt_obj = self._model.objVal\n            self._opt_y1 = self._y1.X\n            self._opt_y2 = self._y2.X\n            self._opt_g = self._g.X\n            print(f'\\tmaster problem is optimal.')\n            print(f'\\topt_obj={self._opt_obj:.2f}')\n            print(f'\\topt_y1={self._opt_y1:.2f}, opt_y2={self._opt_y2:.2f}')\n            print(f'\\topt_g={self._opt_g:.2f}')\n        elif self._model.status == GRB.INFEASIBLE:\n            print(f'\\tmaster problem is infeasible.')\n            opt_status = OptStatus.INFEASIBLE\n        else:\n            print(f'\\tmaster problem encountered error.')\n            opt_status = OptStatus.ERROR\n        \n        print(f'Finish solving master problem.') \n        print('-' * 50)\n        return opt_status\n    \n    def add_feasibility_cut(self, ray_u1, ray_u2) -&gt; None:\n        self._model.addConstr((300-4*self._y1-5*self._y2)*ray_u1 + \n                              (220-2*self._y1-3*self._y2)*ray_u2 &lt;= \n                              0)\n        print(f'Benders feasibility cut added!')\n    \n    def add_optimality_cut(self, opt_u1, opt_u2) -&gt; None:\n        self._model.addConstr((300-4*self._y1-5*self._y2)*opt_u1 + \n                              (220-2*self._y1-3*self._y2)*opt_u2 &lt;= \n                              self._g)\n        print(f'Benders optimality cut added!')\n    \n    def clean_up(self):\n        self._model.dispose()\n        \n    @property\n    def opt_obj(self):\n        return self._opt_obj\n    \n    @property\n    def opt_y1(self):\n        return self._opt_y1\n    \n    @property\n    def opt_y2(self):\n        return self._opt_y2\n    \n    @property\n    def opt_g(self):\n        return self._g\n\n\n\n\nListing 3.17 defines the Benders dual subproblem in a similar fashion. Notice that the update_objective() function is used to set an updated objective function based on the optimal solution identified in the restricted Benders master problem.\n\n\n\n\nListing 3.17: Dual subproblem model\n\n\nclass ManualBendersSubprobSolver:\n    \n    def __init__(self, env):\n        self._model = gp.Model(env=env, name='DSP')\n        \n        # create decision variables\n        self._u1 = self._model.addVar(vtype=GRB.CONTINUOUS,\n                                      lb=-GRB.INFINITY,\n                                      ub=GRB.INFINITY,\n                                      name='u1')\n        self._u2 = self._model.addVar(vtype=GRB.CONTINUOUS,\n                                      lb=-GRB.INFINITY,\n                                      ub=GRB.INFINITY,\n                                      name='u2')\n        \n        # create constraints\n        self._model.addConstr(2*self._u1+4*self._u2 &lt;= 8, name='c1')\n        self._model.addConstr(3*self._u1+2*self._u2 &lt;= 12, name='c2')\n        self._model.addConstr(2*self._u1+3*self._u2 &lt;= 10, name='c3')\n        \n        self._model.setObjective(1, GRB.MAXIMIZE)\n        self._model.update()\n        \n        self._opt_obj = None\n        self._opt_u1 = None\n        self._opt_u2 = None\n        self._ray_u1 = None\n        self._ray_u2 = None\n    \n    def solve(self):\n        print('-' * 50)\n        print(f'Start solving dual subproblem.')\n        self._model.optimize()\n        \n        status = None\n        if self._model.status == GRB.OPTIMAL:\n            self._opt_obj = self._model.objVal\n            self._opt_u1 = self._u1.X\n            self._opt_u2 = self._u2.X\n            status = OptStatus.OPTIMAL\n            print(f'\\tdual subproblem is optimal.')\n            print(f'\\topt_obj={self._opt_obj:.2f}')\n            print(f'\\topt_y1={self._opt_u1:.2f}, opt_y2={self._opt_u2:.2f}')\n        elif self._model.status == GRB.UNBOUNDED:\n            status = OptStatus.UNBOUNDED\n            print(f'\\tdual subproblem is unbounded!')\n            self._ray_u1 = self._u1.UnbdRay\n            self._ray_u2 = self._u2.UnbdRay\n            print(f'\\textreme ray (u1, u2) = ({self._ray_u1}, {self._ray_u2})')\n        else:\n            status = OptStatus.ERROR\n        \n        print(f'Finish solving dual subproblem.')\n        print('-' * 50)\n        return status\n    \n    def update_objective(self, opt_y1, opt_y2):\n        self._model.setObjective(\n            (300-4*opt_y1-5*opt_y2)*self._u1 + \n            (220-2*opt_y1-3*opt_y2)*self._u2, \n            GRB.MAXIMIZE)\n        print(f'dual subproblem objective updated!')\n    \n    def clean_up(self):\n        self._model.dispose()\n        \n    @property\n    def opt_obj(self):\n        return self._opt_obj\n    \n    @property\n    def opt_u1(self):\n        return self._opt_u1\n    \n    @property\n    def opt_u2(self):\n        return self._opt_u2\n    \n    @property\n    def ray_u1(self):\n        return self._ray_u1\n    \n    @property\n    def ray_u2(self):\n        return self._ray_u2\n\n\n\n\nListing 3.18 shows the control flow of Benders decomposition. The main logic is stated as a while loop, in which the master problem and dual subproblem are solved sequentially within each iteration. Depending on whether the subproblem is optimal or unbounded, an optimality or feasibility cut is added to the master problem. The process continues until the gap between the lower bound and the upper bound is within a certain threshold.\n\n\n\n\nListing 3.18: Benders decomposition control flow\n\n\nclass ManualBendersDecomposition:\n    \n    def __init__(self, master_solver, dual_subprob_solver):\n        self._master_solver = master_solver\n        self._dual_subprob_solver = dual_subprob_solver\n        \n    \n    def optimize(self) -&gt; OptStatus:\n        eps = 1.0e-5\n        lb = -np.inf\n        ub = np.inf\n        \n        iter = 1\n        while True:\n            print(f\"\\nIteration: {iter}\")\n            iter += 1\n            # solve master problem\n            master_status = self._master_solver.solve()\n            if master_status == OptStatus.INFEASIBLE:\n                return OptStatus.INFEASIBLE\n            \n            # update lower bound\n            lb = np.max([lb, self._master_solver.opt_obj])\n            print(f'Bounds: lb={lb:.2f}, ub={ub:.2f}')\n            \n            opt_y1 = self._master_solver.opt_y1\n            opt_y2 = self._master_solver.opt_y2\n            \n            # solve subproblem\n            self._dual_subprob_solver.update_objective(opt_y1, opt_y2)\n            dsp_status = self._dual_subprob_solver.solve()\n            \n            if dsp_status == OptStatus.OPTIMAL:\n                # update upper bound\n                opt_obj = self._dual_subprob_solver.opt_obj\n                ub = np.min([ub, 15*opt_y1 + 18*opt_y2 + opt_obj])\n                print(f'Bounds: lb={lb:.2f}, ub={ub:.2f}')\n                \n                if ub - lb &lt;= eps:\n                    break\n                \n                opt_u1 = self._dual_subprob_solver.opt_u1\n                opt_u2 = self._dual_subprob_solver.opt_u2\n                self._master_solver.add_optimality_cut(opt_u1, opt_u2) \n            elif dsp_status == OptStatus.UNBOUNDED:\n                ray_u1 = self._dual_subprob_solver.ray_u1\n                ray_u2 = self._dual_subprob_solver.ray_u2\n                self._master_solver.add_feasibility_cut(ray_u1, ray_u2) \n            \n\n\n\n\nListing 3.19 solves the LP problem using the wholesome Benders solver. The optimal solution agrees with the solution obtained in the manual approach.\n\n\n\n\nListing 3.19: Solving the LP problem using Benders decomposition\n\n\nenv = gp.Env('benders', empty=True)\nenv.setParam(\"OutputFlag\",0)\nenv.start()\nmaster_solver = ManualBendersMasterSolver(env)\ndual_subprob_solver = ManualBendersSubprobSolver(env)\n\nbenders_decomposition = ManualBendersDecomposition(master_solver, dual_subprob_solver)\nbenders_decomposition.optimize()\n\n\n\n\n\nIteration: 1\n--------------------------------------------------\nStart solving master problem.\n    master problem is optimal.\n    opt_obj=0.00\n    opt_y1=0.00, opt_y2=0.00\n    opt_g=0.00\nFinish solving master problem.\n--------------------------------------------------\nBounds: lb=0.00, ub=inf\ndual subproblem objective updated!\n--------------------------------------------------\nStart solving dual subproblem.\n    dual subproblem is optimal.\n    opt_obj=1200.00\n    opt_y1=4.00, opt_y2=0.00\nFinish solving dual subproblem.\n--------------------------------------------------\nBounds: lb=0.00, ub=1200.00\nBenders optimality cut added!\n\nIteration: 2\n--------------------------------------------------\nStart solving master problem.\n    master problem is optimal.\n    opt_obj=1080.00\n    opt_y1=0.00, opt_y2=60.00\n    opt_g=0.00\nFinish solving master problem.\n--------------------------------------------------\nBounds: lb=1080.00, ub=1200.00\ndual subproblem objective updated!\n--------------------------------------------------\nStart solving dual subproblem.\n    dual subproblem is unbounded!\n    extreme ray (u1, u2) = (-2.0, 1.0)\nFinish solving dual subproblem.\n--------------------------------------------------\nBenders feasibility cut added!\n\nIteration: 3\n--------------------------------------------------\nStart solving master problem.\n    master problem is optimal.\n    opt_obj=1091.43\n    opt_y1=0.00, opt_y2=54.29\n    opt_g=114.29\nFinish solving master problem.\n--------------------------------------------------\nBounds: lb=1091.43, ub=1200.00\ndual subproblem objective updated!\n--------------------------------------------------\nStart solving dual subproblem.\n    dual subproblem is optimal.\n    opt_obj=114.29\n    opt_y1=4.00, opt_y2=0.00\nFinish solving dual subproblem.\n--------------------------------------------------\nBounds: lb=1091.43, ub=1091.43\n\n\n\n\n3.0.6 Benders decomposition - design and implementation\nThe Benders decomposition algorithm we put together in the last section is a big step towards automating the interaction between the master problem optimizer and the dual subproblem optimizer. However, it is still limited in that both optimizers are tied to a specific problem instance. Even a slight change in the instance data requires an updated optimizer implementation. Ideally, we would like to to have an algorithm that could solve various LP problems as long as they follow the same form.\nIn addition, we might want to have the flexibility to switch to different solvers within the master and dual subproblem optimizers. A good algorithm design should allow alternative implementations with minimal impact on the overall algorithm structure.\nWith these needs in mind, in this section, we aim to design a Benders decomposition algorithm that can solve any LP problems following a standard form and allow various implementations in both the master problem and dual subproblem optimizers.\nWe develop the algorithm in three steps. First, we present a Benders decomposition algorithm design that focuses on the overall algorithm workflow and only the abstract implementations of the master problem and dual subproblem optimizers. Next, an implementation of the Benders decomposition based on Gurobi is demonstrated. Lastly, an alternative implementation based on the open source solver SCIP is illustrated.\n\n3.0.6.1 Benders decomposition algorithm design\nWe could see from the previous sections that Benders decomposition involves three key components:\n\nAn optimizer that solves the master problem\nAn optimizer that solves the dual subproblem\nAn orchestrator that dictates the interaction between the two optimizers\n\nTo be able to solve LP problems of various sizes, both the master and dual subproblem optimizers must take a generic form and not be tied to a fixed number of various and/or constraints. Furthermore, to be able to switch to different solvers, both optimizers need to conform to a common interface.\nTo this end, Listing 3.21 defines a base class for master problem optimizers. The constructor __init__() takes three inputs, namely, objective coefficients, constraint matrix and the right-hand side. Any concrete implementation of the base class is responsible for constructing a model from these three input values using solver-specific modeling languages. The base class also defines several other key functions:\n\nsolve(): this is the function that invokes solver-specific optimization process and saves the corresponding optimization results.\nadd_feasibility_cut(): this function takes an extreme ray identified by the dual subproblem optimizer and adds a feasibility cut to the master problem.\nadd_optimality_cut(): this function takes an optimal solution identified by the dual subproblem optimizer and adds an optimality cut to the master problem.\nopt_obj_val(): this function returns the optimal objective value obtained.\nopt_val_for_complicating_vars(): this function returns the optimal solution values for all the complicating decision variables.\nopt_val_for_surrogate_var(): this function returns the optimal value of the surrogate variable.\n\n\n\n\n\nListing 3.20: Base class for restricted master problem implementations\n\n\nfrom abc import ABC, abstractmethod\nfrom typing import Dict\nimport numpy as np\n\nclass BendersMasterOptimizer(ABC):\n    \"\"\"base class for master solver implementation\n\n    Args:\n        ABC (ABCMeta): helper class\n    \"\"\"\n    @abstractmethod\n    def __init__(self, objective_coefficients: np.array, \n                 constraint_matrix: np.array, \n                 right_hand_side: np.array):\n        \"\"\"constructor for master problem model initialization.\n        Note that two types of variables will be created:\n        - the complicating variables\n        - the surrogate variable\n\n        Args:\n            objective_coefficients (np.array): an array of size n that \n                defines the coefficient value for each variable in the \n                master problem objective function.\n            constraint_matrix (np.array): a matrix of size m * n that \n                defines the constraint coefficients.\n            right_hand_side (np.array): an array of size n that \n                defines the right hand side for each constraint.\n        \"\"\"\n        raise NotImplementedError\n    \n    @abstractmethod\n    def solve(self) -&gt; OptStatus:\n        \"\"\"solve the problem and return optimization status\n\n        Returns:\n            OptStatus: an enum object\n        \"\"\"\n        raise NotImplementedError\n    \n    @abstractmethod\n    def add_feasibility_cut(self, extreme_ray: Dict[int, float]) -&gt; None:\n        \"\"\"add feasibility cut.\n\n        Args:\n            extreme_ray (Dict[int, float]): a mapping between variable key \n                and extreme ray element. For example:\n                extreme_ray = {\n                    0: 1.0,\n                    1: 2.0\n                }\n                It is assumed that the key type is integer.\n        \"\"\"\n        raise NotImplementedError\n    \n    @abstractmethod\n    def add_optimality_cut(self, opt_sol: Dict[int, float]) -&gt; None:\n        \"\"\"add optimality cut.\n\n        Args:\n            opt_sol (Dict[int, float]): a mapping between variable key \n                and optimal solution element. For example:\n                opt_sol = {\n                    0: 1.0,\n                    1: 2.0\n                }\n                It is assumed that the key type is integer.\n        \"\"\"\n        raise NotImplementedError\n    \n    @abstractmethod\n    def opt_obj_val(self) -&gt; float:\n        \"\"\"return the optimal objective value if exists\n\n        Returns:\n            float: objective value\n        \"\"\"\n        raise NotImplementedError\n    \n    @abstractmethod\n    def opt_obj_val_comp(self) -&gt; float:\n        \"\"\"return the optimal objective value for the complicating variables\n\n        Returns:\n            float: objective value for the complicating variables\n        \"\"\"\n        raise NotImplementedError\n    \n    @abstractmethod\n    def opt_val_for_complicating_vars(self) -&gt; Dict[int, float]:\n        \"\"\"return the optimal solution values for complicating variables\n\n        Returns:\n            Dict[int, float]: mapping between variable key and optimal value.\n            For example, opt_val = {\n                0: 2.0,\n                1: 3.0\n            }\n        \"\"\"\n        raise NotImplementedError\n    \n    @abstractmethod\n    def opt_val_for_surrogate_var(self) -&gt; float:\n        \"\"\"return the optimal value for the surrogate variable\n\n        Returns:\n            float: optimal value for the surrogate variable\n        \"\"\"\n        raise NotImplementedError\n\n\n\n\nSimilarly, Listing 3.21 presents a base class for dual subproblem optimizers. The constructor __init__() takes the objective coefficients and constraint matrix that correspond to the variables in the subproblem. These information are required to create variables and constraints for the dual subproblem. However, the objective function will not be instantiated without the optimal solution of the restricted master problem. This base class also contains several other key functions:\n\nsolve(): this is the function that calls solver-specific procedure to solve the underlying dual subproblem.\nupdate_objective(): this function takes the optimal solution obtained by the master problem optimizer and updates the objective function for the dual subproblem.\nopt_obj_val(): this function returns the optimal objective values identified by the optimizer.\nopt_sol(): this function returns the optimal solution identified by the optimizer.\nextreme_ray(): this function returns the extreme ray identified by the optimizer.\n\n\n\n\n\nListing 3.21: Base class for restricted master problem implementations\n\n\nfrom abc import ABC, abstractmethod\nfrom typing import Dict\nimport numpy as np\n\nclass BendersDspOptimizer(ABC):\n    \"\"\"base class for dual subproblem implementation\n\n    Args:\n        ABC (ABCMeta): helper class\n    \"\"\"\n    \n    @abstractmethod\n    def __init__(self, objective_coefficients: np.array, \n                 constraint_matrix: np.array):\n        \"\"\"constructor for dual subproblem model initialization.\n\n        Args:\n            objective_coefficients (np.array): an array of size m that \n                represents the coefficient value for each variable in the \n                original problem objective function.\n            constraint_matrix (np.array): a matrix of size m * n that \n                defines the constraint coefficients in the original problem.\n        \"\"\"\n        raise NotImplementedError\n    \n    @abstractmethod\n    def solve(self) -&gt; OptStatus:\n        \"\"\"solve the problem and return optimization status\n\n        Returns:\n            OptStatus: an enum object\n        \"\"\"\n        raise NotImplementedError\n    \n    @abstractmethod\n    def update_objective(self, opt_sol_rbmp: Dict[int, float],\n                         constraint_matrix_rbmp: np.array,\n                         right_hand_side_rbmp: np.array) -&gt; None:\n        \"\"\"update the objective function for the dual subproblem.\n\n        Args:\n            opt_sol_rbmp (Dict[int, float]): optimal solution of the \n                restricted master problem\n            constraint_matrix_rbmp (np.array): constraint matrix \n                associated with the complicating variables in the \n                master problem\n            right_hand_side_rbmp (np.array): right-hand side of \n                the original problem\n        \"\"\"\n        raise NotImplementedError\n    \n    @abstractmethod\n    def opt_obj_val(self) -&gt; float:\n        \"\"\"return the optimal objective value if exists\n\n        Returns:\n            float: objective value\n        \"\"\"\n        raise NotImplementedError\n    \n    @abstractmethod\n    def opt_sol(self) -&gt; Dict[int, float]:\n        \"\"\"return the optimal solution values\n\n        Returns:\n            Dict[int, float]: mapping between variable key and optimal value.\n            For example, opt_sol = {\n                0: 2.0,\n                1: 4.0\n            }\n        \"\"\"\n        raise NotImplementedError\n    \n    @abstractmethod\n    def extreme_ray(self) -&gt; Dict[int, float]:\n        \"\"\"return the identified extreme ray\n\n        Returns:\n            Dict[int, float]: mapping between variable key and ray element.\n            For example, extreme_ray = {\n                0: 3.5,\n                1: 6.0\n            }\n        \"\"\"\n        raise NotImplementedError\n\n\n\n\n\n\n\n\nListing 3.22: Generic Benders decomposition for LP problems\n\n\nclass BendersOptimizerConsole:\n    \n    def __init__(self, master_optimizer: BendersMasterOptimizer, \n                 dsp_optimizer: BendersDspOptimizer):\n        self._master_optimizer = master_optimizer\n        self._dsp_optimizer = dsp_optimizer\n    \n    def optimize(self, verbose=False) -&gt; OptStatus:\n        eps = 1.0e-5\n        lb = -np.inf\n        ub = np.inf\n        \n        iter = 0\n        while True:\n            iter += 1\n            if verbose: \n                print(f'\\nIteration: {iter}')\n                \n            # solve master problem\n            master_status = self._master_optimizer.solve()\n            if master_status == OptStatus.INFEASIBLE:\n                if verbose:\n                    print(f'Model is infeasible!')\n                return OptStatus.INFEASIBLE\n            \n            # update lower bound\n            lb = np.max([lb, self._master_optimizer.opt_obj_val])\n            if verbose:\n                print(f'Bounds: lb={lb:.2f}, ub={ub:.2f}')\n            \n            # solve subproblem\n            opt_val_comp = self._master_optimizer.opt_val_for_complicating_vars\n            self._dsp_optimizer.update_objective(opt_val_comp)\n            dsp_status = self._dsp_optimizer.solve()\n            \n            if dsp_status == OptStatus.OPTIMAL:\n                if verbose:\n                    print(f'DSP is optimal!')\n                # update upper bound\n                opt_obj = self._dsp_optimizer.opt_obj_val                \n                opt_obj_val_comp = self._master_optimizer.opt_obj_val_comp\n                ub = np.min([ub, opt_obj_val_comp + opt_obj])\n                if verbose:\n                    print(f'Bounds: lb={lb:.2f}, ub={ub:.2f}')\n                \n                if ub - lb &lt;= eps:\n                    return OptStatus.OPTIMAL\n                \n                opt_sol = self._dsp_optimizer.opt_sol\n                self._master_optimizer.add_optimality_cut(opt_sol) \n            elif dsp_status == OptStatus.UNBOUNDED:\n                if verbose:\n                    print(f'DSP is unbounded!!!')\n                extreme_ray = self._dsp_optimizer.extreme_ray\n                self._master_optimizer.add_feasibility_cut(extreme_ray)\n            else:\n                if verbose:\n                    print(f\"DSP solve ERROR!!!\")\n                return OptStatus.ERROR\n\n\n\n\n\n\n3.0.6.2 Master and subproblem solvers based on Gurobi\nListing 3.23 implements a master problem solver class named GenericMasterSolverGurobi for (RBMP) characterized by the cost coefficient f, the constraint matrix B and right-hand side b. The constructor initializes the complicating variables _y and the dummy variable _g. The solve() function solves the problem and retrieves the optimal solution if exists. Moreover, the solver provides functions to add optimality and feasibility cuts to the existing model.\n\n\n\n\nListing 3.23: Generic Benders master problem solver for LP problems\n\n\nclass BendersMasterOptimizerGurobi(BendersMasterOptimizer):\n    \n    def __init__(self, f: np.array, B: np.array, b: np.array):\n        # save data\n        self._f = f\n        self._B = B\n        self._b = b \n        \n        # env and model\n        self._env = gp.Env('MasterEnv', empty=True)\n        self._env.setParam(\"OutputFlag\",0)\n        self._env.start()\n        self._model = gp.Model(env=self._env, name='MasterSolver')\n        \n        # create variables\n        self._num_y_vars = len(f)\n        self._y = self._model.addVars(self._num_y_vars, \n                                      lb=0,\n                                      vtype=GRB.CONTINUOUS, \n                                      name='y')\n        self._g = self._model.addVar(vtype=GRB.CONTINUOUS, \n                                     lb=0, \n                                     name='g')\n        \n        # create objective\n        self._model.setObjective(\n            gp.quicksum(self._f[i] * self._y.get(i) \n                        for i in range(self._num_y_vars)) + \n            self._g,  \n            GRB.MINIMIZE)\n        self._model.update()\n        \n        self._opt_obj = None\n        self._opt_obj_y = None\n        self._opt_y = None\n        self._opt_g = None\n        \n    def solve(self) -&gt; OptStatus:\n        print('-' * 50)\n        print(f'Start solving master problem.')\n        self._model.optimize()\n        \n        opt_status = None\n        if self._model.status == GRB.OPTIMAL:\n            opt_status = OptStatus.OPTIMAL\n            self._opt_obj = self._model.objVal\n            self._opt_y = {\n                i: self._y.get(i).X\n                for i in range(self._num_y_vars)\n            }\n            self._opt_g = self._g.X\n            self._opt_obj_y = self._opt_obj - self._opt_g\n            print(f'\\tmaster problem is optimal.')\n            print(f'\\topt_obj={self._opt_obj:.2f}')\n            print(f'\\topt_g={self._opt_g:.2f}')\n            for j in range(self._num_y_vars):\n                print(f'\\topt_y{j}={self._y.get(j).X}')\n        elif self._model.status == GRB.INFEASIBLE:\n            print(f'\\tmaster problem is infeasible.')\n            opt_status = OptStatus.INFEASIBLE\n        else:\n            print(f'\\tmaster problem encountered error.')\n            opt_status = OptStatus.ERROR\n        \n        print(f'Finish solving master problem.') \n        print('-' * 50)\n        return opt_status\n    \n    def add_feasibility_cut(self, ray_u: dict) -&gt; None:\n        constr_expr = [\n            ray_u.get(u_idx) * \n            (\n                self._b[u_idx] - \n                gp.quicksum(\n                    self._B[u_idx][j] * self._y.get(j) \n                    for j in range(self._num_y_vars)\n                )\n            )\n            for u_idx in ray_u.keys()\n        ]\n        self._model.addConstr(gp.quicksum(constr_expr) &lt;= 0)\n        print(f'Benders feasibility cut added!')\n    \n    def add_optimality_cut(self, opt_u: dict) -&gt; None:\n        constr_expr = [\n            opt_u.get(u_idx) * \n            (\n                self._b[u_idx] - \n                gp.quicksum(\n                    self._B[u_idx][j] * self._y.get(j) \n                    for j in range(self._num_y_vars)\n                )\n            )\n            for u_idx in opt_u.keys()\n        ]\n        self._model.addConstr(gp.quicksum(constr_expr) &lt;= self._g)\n        self._model.update()\n        print(f'Benders optimality cut added!')\n    \n    def clean_up(self):\n        self._model.dispose()\n        self._env.dispose()\n        \n    def save_model(self, filename):\n        self._model.write(filename)\n        \n    @property\n    def f(self):\n        return self._f\n        \n    @property\n    def opt_obj(self):\n        return self._opt_obj\n    \n    @property\n    def opt_obj_y(self):\n        return self._opt_obj_y\n    \n    @property\n    def opt_y(self):\n        return self._opt_y\n    \n    @property\n    def opt_g(self):\n        return self._g\n\n\n\n\nListing 3.24 presents a solver for (DSP) that’s defined by the objective function coefficient c and constraint matrix A. The model objective function could be updated by update_objective() with the latest value of y. Notice that, the optimal solution is saved to _opt_u if the underlying problem is optimal. Otherwise, an extreme ray is retrieved and stored in _extreme_ray.\n\n\n\n\nListing 3.24: Generic Benders dual subproblem solver for LP problems\n\n\nclass GenericSubprobSolverGurobi:\n    \n    def __init__(self, A: np.array, c: np.array, B: np.array, b: np.array):\n        # save data\n        self._A = A \n        self._c = c \n        self._b = b \n        self._B = B\n        \n        # env and model\n        self._env = gp.Env('SubprobEnv', empty=True)\n        self._env.setParam(\"OutputFlag\",0)\n        self._env.start()\n        self._model = gp.Model(env=self._env, name='SubprobSolver')\n\n        # create variables\n        self._num_vars = len(b)\n        self._u = self._model.addVars(self._num_vars, \n                                      vtype=GRB.CONTINUOUS,\n                                      lb=-GRB.INFINITY,\n                                      ub=GRB.INFINITY,\n                                      name='u')\n\n        # create constraints\n        for c_idx in range(len(c)):\n            self._model.addConstr(\n                gp.quicksum(A[:,c_idx][i] * self._u.get(i) \n                            for i in range(len(b))) &lt;= c[c_idx]\n            )\n        \n        self._opt_obj = None\n        self._opt_u = None\n        self._ray_u = None\n        \n    def solve(self):\n        print('-' * 50)\n        print(f'Start solving dual subproblem.')\n        self._model.setParam(GRB.Param.DualReductions, 0)\n        self._model.setParam(GRB.Param.InfUnbdInfo, 1)\n        self._model.optimize()\n        \n        status = None\n        if self._model.status == GRB.OPTIMAL:\n            self._opt_obj = self._model.objVal\n            self._opt_u = {\n                i: self._u.get(i).X\n                for i in range(self._num_vars)\n            }\n            status = OptStatus.OPTIMAL\n            print(f'\\tdual subproblem is optimal.')\n            print(f'\\topt_obj={self._opt_obj:.2f}')\n            for i in range(self._num_vars):\n                print(f'\\topt_u{i}={self._u.get(i).X}')\n        elif self._model.status == GRB.UNBOUNDED:\n            status = OptStatus.UNBOUNDED\n            self._ray_u = {\n                i: self._u.get(i).UnbdRay\n                for i in range(self._num_vars)\n            }\n            print(f'dual subproblem is unbounded')\n        else:\n            print(f'dual subproblem solve ERROR!')\n            status = OptStatus.ERROR\n        \n        print(f'Finish solving dual subproblem.')\n        print('-' * 50)\n        return status\n\n    def update_objective(self, opt_y: dict):\n        obj_expr = [\n            self._u.get(u_idx) * \n            (\n                self._b[u_idx] - \n                sum(self._B[u_idx][j] * opt_y.get(j) \n                    for j in range(len(opt_y))\n                )\n            )\n            for u_idx in range(self._num_vars)\n        ]\n        self._model.setObjective(gp.quicksum(obj_expr), GRB.MAXIMIZE)\n        print(f'dual subproblem objective updated!')\n    \n    def clean_up(self):\n        self._model.dispose()\n        self._env.dispose()\n        \n    def save_model(self, filename):\n        self._model.write(filename)\n        \n    @property\n    def opt_obj(self):\n        return self._opt_obj\n    \n    @property\n    def opt_u(self):\n        return self._opt_u\n    \n    @property\n    def ray_u(self):\n        return self._ray_u\n\n\n\n\nIn Listing 3.26, we utilize the freshly baked solver to tackle the serious LP problem presented in the previous sections. The output shows that the same optimal objective value of 1091.43 was obtained in the end.\n\n\n\n\nListing 3.25: Solving the LP problem using Benders decomposition\n\n\nimport numpy as np\n\nc = np.array([8, 12, 10])\nf = np.array([15, 18])\nA = np.array([[2, 3, 2], [4, 2, 3]])\nB = np.array([[4, 5], [2, 3]])\nb = np.array([300, 220])\n\nmaster_solver = GenericMasterSolverGurobi(f, B, b)\ndual_subprob_solver = GenericSubprobSolverGurobi(A, c, B, b)\n\nbenders_solver = GenericBendersDecomposition(master_solver, dual_subprob_solver)\nstatus = benders_solver.optimize()\n\n\n\n\n\nIteration: 1\n--------------------------------------------------\nStart solving master problem.\n    master problem is optimal.\n    opt_obj=0.00\n    opt_g=0.00\n    opt_y0=0.0\n    opt_y1=0.0\nFinish solving master problem.\n--------------------------------------------------\nBounds: lb=0.00, ub=inf\ndual subproblem objective updated!\n--------------------------------------------------\nStart solving dual subproblem.\n    dual subproblem is optimal.\n    opt_obj=1200.00\n    opt_u0=4.0\n    opt_u1=0.0\nFinish solving dual subproblem.\n--------------------------------------------------\nDSP is optimal!\nBounds: lb=0.00, ub=1200.00\nBenders optimality cut added!\n\nIteration: 2\n--------------------------------------------------\nStart solving master problem.\n    master problem is optimal.\n    opt_obj=1080.00\n    opt_g=0.00\n    opt_y0=0.0\n    opt_y1=60.0\nFinish solving master problem.\n--------------------------------------------------\nBounds: lb=1080.00, ub=1200.00\ndual subproblem objective updated!\n--------------------------------------------------\nStart solving dual subproblem.\ndual subproblem is unbounded\nFinish solving dual subproblem.\n--------------------------------------------------\nDSP is unbounded!!!\nBenders feasibility cut added!\n\nIteration: 3\n--------------------------------------------------\nStart solving master problem.\n    master problem is optimal.\n    opt_obj=1091.43\n    opt_g=114.29\n    opt_y0=0.0\n    opt_y1=54.285714285714285\nFinish solving master problem.\n--------------------------------------------------\nBounds: lb=1091.43, ub=1200.00\ndual subproblem objective updated!\n--------------------------------------------------\nStart solving dual subproblem.\n    dual subproblem is optimal.\n    opt_obj=114.29\n    opt_u0=4.0\n    opt_u1=0.0\nFinish solving dual subproblem.\n--------------------------------------------------\nDSP is optimal!\nBounds: lb=1091.43, ub=1091.43\n\n\n\n\n3.0.6.3 Master and subproblem solvers based on SCIP\n\nimport pyscipopt\n\nclass GenericMasterSolverSCIP:\n    \n    def __init__(self, f: np.array, B: np.array, b: np.array):\n        # save data\n        self._f = f\n        self._B = B\n        self._b = b \n        \n        # env and model\n        self._model = pyscipopt.Model('MasterSolver')\n        \n        # create variables\n        self._num_y_vars = len(f)\n        self._y = {\n            i: self._model.addVar(lb=0, vtype='C', name=f'y{i}')\n            for i in range(self._num_y_vars)\n        }\n        self._g = self._model.addVar(lb=0,\n                                     vtype='C',\n                                     name='g')\n        \n        # create objective\n        self._model.setObjective(\n            pyscipopt.quicksum(self._f[i] * self._y.get(i) \n                        for i in range(self._num_y_vars)) + \n            self._g,  \n            'maximize')\n        \n        self._opt_obj = None\n        self._opt_obj_y = None\n        self._opt_y = None\n        self._opt_g = None\n        \n    def solve(self) -&gt; OptStatus:\n        print('-' * 50)\n        print(f'Start solving master problem.')\n        self._model.setPresolve(pyscipopt.SCIP_PARAMSETTING.OFF)\n        self._model.setHeuristics(pyscipopt.SCIP_PARAMSETTING.OFF)\n        self._model.disablePropagation()\n        self._model.optimize()\n        \n        opt_status = None\n        print(self._model.getStatus())\n        if self._model.getStatus() == 'optimal':\n            opt_status = OptStatus.OPTIMAL\n            self._opt_obj = self._model.getObjVal()\n            self._opt_y = {\n                i: self._model.getVal(self._y.get(i))\n                for i in range(self._num_y_vars)\n            }\n            self._opt_g = self._model.getVal(self._g)\n            self._opt_obj_y = self._opt_obj - self._opt_g\n            print(f'\\tmaster problem is optimal.')\n            print(f'\\topt_obj={self._opt_obj:.2f}')\n            print(f'\\topt_g={self._opt_g:.2f}')\n            for j in range(self._num_y_vars):\n                print(f'\\topt_y{j}={self._opt_y.get(j)}')\n        elif self._model.getStatus() == 'infeasible':\n            print(f'\\tmaster problem is infeasible.')\n            opt_status = OptStatus.INFEASIBLE\n        else:\n            print(f'\\tmaster problem encountered error.')\n            opt_status = OptStatus.ERROR\n        \n        print(f'Finish solving master problem.') \n        print('-' * 50)\n        return opt_status\n    \n    def add_feasibility_cut(self, ray_u: dict) -&gt; None:\n        constr_expr = [\n            ray_u.get(u_idx) * \n            (\n                self._b[u_idx] - \n                pyscipopt.quicksum(\n                    self._B[u_idx][j] * self._y.get(j) \n                    for j in range(self._num_y_vars)\n                )\n            )\n            for u_idx in ray_u.keys()\n        ]\n        self._model.addCons(pyscipopt.quicksum(constr_expr) &lt;= 0)\n        print(f'Benders feasibility cut added!')\n    \n    def add_optimality_cut(self, opt_u: dict) -&gt; None:\n        constr_expr = [\n            opt_u.get(u_idx) * \n            (\n                self._b[u_idx] - \n                pyscipopt.quicksum(\n                    self._B[u_idx][j] * self._y.get(j) \n                    for j in range(self._num_y_vars)\n                )\n            )\n            for u_idx in opt_u.keys()\n        ]\n        self._model.addCons(pyscipopt.quicksum(constr_expr) &lt;= self._g)\n        self._model.update()\n        print(f'Benders optimality cut added!')\n    \n    @property\n    def f(self):\n        return self._f\n        \n    @property\n    def opt_obj(self):\n        return self._opt_obj\n    \n    @property\n    def opt_obj_y(self):\n        return self._opt_obj_y\n    \n    @property\n    def opt_y(self):\n        return self._opt_y\n    \n    @property\n    def opt_g(self):\n        return self._g\n\n\nimport pyscipopt\n\nclass GenericSubprobSolverSCIP:\n    \n    def __init__(self, A: np.array, c: np.array, B: np.array, b: np.array):\n        # save data\n        self._A = A \n        self._c = c \n        self._b = b \n        self._B = B\n        \n        # env and model\n        self._model = pyscipopt.Model('SubprobSolver')\n\n        # create variables\n        self._num_vars = len(b)\n        self._u = {\n            i: self._model.addVar(vtype='C',\n                                  lb=-self._model.infinity(),\n                                  ub=self._model.infinity(),\n                                  name=f'u{i}')\n            for i in range(self._num_vars)\n        }\n\n        # create constraints\n        for c_idx in range(len(c)):\n            self._model.addCons(\n                pyscipopt.quicksum(A[:,c_idx][i] * self._u.get(i) \n                            for i in range(len(b))) &lt;= c[c_idx]\n            )\n        \n        self._opt_obj = None\n        self._opt_u = None\n        self._ray_u = None\n        \n    def solve(self):\n        print('-' * 50)\n        print(f'Start solving dual subproblem.')\n        self._model.setPresolve(pyscipopt.SCIP_PARAMSETTING.OFF)\n        self._model.setHeuristics(pyscipopt.SCIP_PARAMSETTING.OFF)\n        self._model.disablePropagation()\n        self._model.optimize()\n        \n        status = None\n        if self._model.getStatus() == 'optimal':\n            self._opt_obj = self._model.getObjVal()\n            self._opt_u = {\n                i: self._model.getVal(self._u.get(i))\n                for i in range(self._num_vars)\n            }\n            status = OptStatus.OPTIMAL\n            print(f'\\tdual subproblem is optimal.')\n            print(f'\\topt_obj={self._opt_obj:.2f}')\n            for i in range(self._num_vars):\n                print(f'\\topt_u{i}={self._opt_u.get(i)}')\n        elif self._model.getStatus() == 'unbounded':\n            status = OptStatus.UNBOUNDED\n            hasRay = self._model.hasPrimalRay()\n            print(f'primal ray exists!')\n            ray = self._model.getPrimalRay()\n            self._ray_u = {\n                i: ray[i]\n                for i in range(self._num_vars)\n            }\n            print(f'dual subproblem is unbounded')\n        else:\n            print(f'dual subproblem solve ERROR!')\n            status = OptStatus.ERROR\n        \n        print(f'Finish solving dual subproblem.')\n        print('-' * 50)\n        return status\n\n    def update_objective(self, opt_y: dict):\n        obj_expr = [\n            self._u.get(u_idx) * \n            (\n                self._b[u_idx] - \n                sum(self._B[u_idx][j] * opt_y.get(j) \n                    for j in range(len(opt_y))\n                )\n            )\n            for u_idx in range(self._num_vars)\n        ]\n        self._model.setObjective(pyscipopt.quicksum(obj_expr), GRB.MAXIMIZE)\n        print(f'dual subproblem objective updated!')\n    \n    @property\n    def opt_obj(self):\n        return self._opt_obj\n    \n    @property\n    def opt_u(self):\n        return self._opt_u\n    \n    @property\n    def ray_u(self):\n        return self._ray_u\n\nListing 3.26 solves same the LP problem that we have been tackling in the previous sections. The output confirms that the same optimal solution is identified as in the last section.\n\n\n\n\nListing 3.26: Solving the LP problem using Benders decomposition\n\n\nimport numpy as np\n\nc = np.array([8, 12, 10])\nf = np.array([15, 18])\nA = np.array([[2, 3, 2], [4, 2, 3]])\nB = np.array([[4, 5], [2, 3]])\nb = np.array([300, 220])\n\nmaster_solver = GenericMasterSolverSCIP(f, B, b)\ndual_subprob_solver = GenericSubprobSolverSCIP(A, c, B, b)\n\nbenders_solver = GenericBendersDecomposition(master_solver, dual_subprob_solver)\nbenders_solver.optimize()\n\n\n\n\n\nIteration: 1\n--------------------------------------------------\nStart solving master problem.\nunbounded\n    master problem encountered error.\nFinish solving master problem.\n--------------------------------------------------\npresolving:\n   (0.0s) symmetry computation started: requiring (bin +, int +, cont +), (fixed: bin -, int -, cont -)\n   (0.0s) no symmetry present (symcode time: 0.00)\npresolving (0 rounds: 0 fast, 0 medium, 0 exhaustive):\n 0 deleted vars, 0 deleted constraints, 0 added constraints, 0 tightened bounds, 0 added holes, 0 changed sides, 0 changed coefficients\n 0 implications, 0 cliques\npresolved problem has 3 variables (0 bin, 0 int, 0 impl, 3 cont) and 0 constraints\nPresolving Time: 0.00\n\n time | node  | left  |LP iter|LP it/n|mem/heur|mdpt |vars |cons |rows |cuts |sepa|confs|strbr|  dualbound   | primalbound  |  gap   | compl. \n* 0.0s|     1 |     0 |     0 |     - |    LP  |   0 |   3 |   0 |   0 |   0 |  0 |   0 |   0 |      --      |      --      |   0.00%| unknown\n  0.0s|     1 |     0 |     0 |     - |   568k |   0 |   3 |   0 |   0 |   0 |  0 |   0 |   0 |      --      |      --      |   0.00%| unknown\n\nSCIP Status        : problem is solved [unbounded]\nSolving Time (sec) : 0.00\nSolving Nodes      : 1\nPrimal Bound       : +1.00000000000000e+20 (1 solutions)\nDual Bound         : +1.00000000000000e+20\nGap                : 0.00 %\n\n\nTypeError: '&gt;=' not supported between instances of 'float' and 'NoneType'\n\n\n\n\n3.0.6.4 Detect infeasibility\n\nimport numpy as np\n\nnp.random.seed(142)\nc = np.random.randint(2, 6, size=20)\nf = np.random.randint(1, 15, size=10)\nA = np.random.randint(2, 6, size=(20, 20))\nB = np.random.randint(2, 26, size=(20, 10))\nb = np.random.randint(20, 50, size=20)\n\nobj_coeff = np.concatenate([c, f])\nconstr_mat = np.concatenate([A, B], axis=1)\nrhs = b\n\n\ngurobi_solver = LpSolverGurobi(obj_coeff, constr_mat, rhs)\ngurobi_solver.save_model('problem2.lp')\ngurobi_solver.optimize()\n\nModel is infeasible!\n\n\n\nscip_solver = LpSolverSCIP(obj_coeff, constr_mat, rhs)\nscip_solver.optimize()\n\nModel is infeasible!\n\n\n\nmaster_solver = GenericLpMasterSolver(f, B, b)\ndual_subprob_solver = GenericLpSubprobSolver(A, c, B, b)\n\nbenders_solver = GenericBendersSolver(master_solver, dual_subprob_solver)\nbenders_solver.optimize()\n\n\nIteration: 1\n--------------------------------------------------\nStart solving master problem.\n    master problem is optimal.\n    opt_obj=0.00\n    opt_g=0.00\n    opt_y0=0.0\n    opt_y1=0.0\nFinish solving master problem.\n--------------------------------------------------\nBounds: lb=0.00, ub=inf\ndual subproblem objective updated!\n--------------------------------------------------\nStart solving dual subproblem.\n    dual subproblem is optimal.\n    opt_obj=1200.00\n    opt_u0=4.0\n    opt_u1=0.0\nFinish solving dual subproblem.\n--------------------------------------------------\nDSP is optimal!\nBounds: lb=0.00, ub=1200.00\nBenders optimality cut added!\n\nIteration: 2\n--------------------------------------------------\nStart solving master problem.\n    master problem is optimal.\n    opt_obj=1080.00\n    opt_g=0.00\n    opt_y0=0.0\n    opt_y1=60.0\nFinish solving master problem.\n--------------------------------------------------\nBounds: lb=1080.00, ub=1200.00\ndual subproblem objective updated!\n--------------------------------------------------\nStart solving dual subproblem.\ndual subproblem is unbounded\nFinish solving dual subproblem.\n--------------------------------------------------\nDSP is unbounded!!!\nBenders feasibility cut added!\n\nIteration: 3\n--------------------------------------------------\nStart solving master problem.\n    master problem is optimal.\n    opt_obj=1091.43\n    opt_g=114.29\n    opt_y0=0.0\n    opt_y1=54.285714285714285\nFinish solving master problem.\n--------------------------------------------------\nBounds: lb=1091.43, ub=1200.00\ndual subproblem objective updated!\n--------------------------------------------------\nStart solving dual subproblem.\n    dual subproblem is optimal.\n    opt_obj=114.29\n    opt_u0=4.0\n    opt_u1=0.0\nFinish solving dual subproblem.\n--------------------------------------------------\nDSP is optimal!\nBounds: lb=1091.43, ub=1091.43\n\n\n\n\n\n3.0.7 Implementation with callbacks\n\n\n3.0.8 Testing and validation",
    "crumbs": [
      "Benders Decomposition",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Solving Linear Programming Problems with Benders Decomposition</span>"
    ]
  },
  {
    "objectID": "lagrange-theory.html",
    "href": "lagrange-theory.html",
    "title": "4  Lagrangian Relaxation Theories",
    "section": "",
    "text": "4.1 Lagrangian Relaxation Reformulation\nAs with the case of applying other decomposition algorithm, the first step in utilizing Lagrangian Relaxation is to transform our problem at hand into a suitable format. This involves two critical steps:\nArguably, the first step is more challenging when facing a new optimization problem. The second step is often straightforward to do once one recognize the required structure is present in the model formulation. My experience in using the Lagrangian Relaxation is through problem solving. It is natural to build up intuition once one solves more optimization problem with this powerful algorithm. In this chapter and following chapter, we will use Lagrangian Relaxation to solve a number of classical optimization problems. Hopefully, the exercise will help us gain enough sense of recognizing when Lagrangian Relaxation is applicable.\nRegarding the second point, we will see that sometimes one original problem formulation invites multiple forms of Lagrangian relaxations and some are better than others in terms of providing tighter bounds.",
    "crumbs": [
      "Lagrangian Relaxation",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Lagrangian Relaxation Theories</span>"
    ]
  },
  {
    "objectID": "lagrange-theory.html#lagrangian-relaxation-reformulation",
    "href": "lagrange-theory.html#lagrangian-relaxation-reformulation",
    "title": "4  Lagrangian Relaxation Theories",
    "section": "",
    "text": "Recognizing the applicability of the Lagrangian Relaxation algorithm.\nModel reformulation.",
    "crumbs": [
      "Lagrangian Relaxation",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Lagrangian Relaxation Theories</span>"
    ]
  },
  {
    "objectID": "lagrange-theory.html#subgradient-search",
    "href": "lagrange-theory.html#subgradient-search",
    "title": "4  Lagrangian Relaxation Theories",
    "section": "4.2 Subgradient Search",
    "text": "4.2 Subgradient Search\nThe essential component of Lagrangian relaxation is the use of Lagrange multipliers to penalize the violation of constraints that we choose to put in the objective function. The determination of the values of Lagrange multipliers is through the subgradient search algorithm, which is outlined in this section and illustrated in following chapters through concrete examples.",
    "crumbs": [
      "Lagrangian Relaxation",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Lagrangian Relaxation Theories</span>"
    ]
  },
  {
    "objectID": "lagrange-assignment.html",
    "href": "lagrange-assignment.html",
    "title": "5  Generalized Assignment Problem",
    "section": "",
    "text": "5.1 Formulation\nFormally, the Generalized Assignment Problem can be defined as follows:\nGiven:\nThe goal is to find an assignment of tasks to agents that minimizes the total cost or maximizes the total profit, while ensuring that each task is assigned to one or more agents, and the total resource requirement of each agent does not exceed its capacity.\nMathematically, the GAP can be formulated as an integer linear programming problem. One possible formulation is as follows:\n\\[\n\\begin{align}\n\\text{min.} &\\quad \\sum_{i=1}^{n} \\sum_{j=1}^{m} c_{ij} x_{ij} \\label{gap-obj}\\\\\n\\text{s.t.} &\\quad \\sum_{j=1}^{m} x_{ij} = 1, \\ \\forall i = 1, 2, ..., n \\label{gap-cons1}\\\\\n&\\quad \\sum_{i=1}^{n} r_{ij} x_{ij} \\leq b_j, \\  \\forall j = 1, 2, ..., m \\label{gap-cons2}\\\\\n&\\quad x_{ij} \\in \\{0, 1\\}, \\ \\forall i = 1, 2, ..., n, j = 1, 2, ..., m \\label{gap-cons3}\n\\end{align}\n\\]\nwhere \\(x_{ij}\\) is a binary decision variable that equals 1 if task \\(i\\) is assigned to agent \\(j\\), and 0 otherwise.\nThe first set of constraints ensures that each task is assigned to exactly one agent, and the second set of constraints ensures that the total resource requirement of each agent does not exceed its capacity.\nSolving the GAP can be computationally challenging, especially for large instances, as it is a generalization of the classic assignment problem, which is known to be polynomial-time solvable. Various algorithms and heuristics, such as branch and bound, dynamic programming, and approximation algorithms, can be employed to find feasible or optimal solutions to the GAP.",
    "crumbs": [
      "Lagrangian Relaxation",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Generalized Assignment Problem</span>"
    ]
  },
  {
    "objectID": "lagrange-assignment.html#formulation",
    "href": "lagrange-assignment.html#formulation",
    "title": "5  Generalized Assignment Problem",
    "section": "",
    "text": "A set of tasks, \\(T = \\{1, 2, ..., n\\}\\)\nA set of agents, \\(A = \\{1, 2, ..., m\\}\\)\nFor each task \\(i\\) and agent \\(j\\), a cost or profit \\(c_{ij}\\) associated with assigning task \\(i\\) to agent \\(j\\)\nFor each task \\(i\\) and agent \\(j\\), a resource requirement \\(r_{ij}\\) specifying the amount of resource needed from agent \\(j\\) to complete task \\(i\\)\nFor each agent \\(j\\), a capacity \\(b_j\\) specifying the maximum amount of resource that agent \\(j\\) can contribute",
    "crumbs": [
      "Lagrangian Relaxation",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Generalized Assignment Problem</span>"
    ]
  },
  {
    "objectID": "lagrange-assignment.html#lagrangian-relaxation",
    "href": "lagrange-assignment.html#lagrangian-relaxation",
    "title": "5  Generalized Assignment Problem",
    "section": "5.2 Lagrangian Relaxation",
    "text": "5.2 Lagrangian Relaxation\nThe essence of Lagrangian relaxation is to choose some ‘hard’ constraints in the original model formulation and put them into the objective function. In the meantime, Lagrange multipliers are used to penalize the violations of these constraints. In the GAP formulation, we could choose the constraints \\(\\eqref{gap-cons1}\\) and put them into the objective function, which gives us the corresponding Lagrangian relaxation:\n\\[\n\\begin{align}\nLR(v): \\text{min.} &\\quad \\sum_{i=1}^{n} \\sum_{j=1}^{m} c_{ij} x_{ij} + \\sum_{i=1}^{n} v_i (\\sum_{j=1}^{m} x_{ij} - 1) \\label{gap-lr-obj}\\\\\n\\text{s.t.} &\\quad \\sum_{i=1}^{n} r_{ij} x_{ij} \\leq b_j, \\  \\forall j = 1, 2, ..., m \\label{gap-lr-cons1}\\\\\n&\\quad x_{ij} \\in \\{0, 1\\}, \\ \\forall i = 1, 2, ..., n, j = 1, 2, ..., m \\label{gap-lr-cons2}\n\\end{align}\n\\]\nIn the above formulation, \\(v_i\\) is the Lagrange multiplier associated with each task \\(i\\). Note that the optimal objective value of \\(LR(v)\\) for a given \\(v\\) serves as a lower bound of the original problem. Our goal is then to find the best value of \\(v\\) such that the best lower bound is obtained for the original problem.",
    "crumbs": [
      "Lagrangian Relaxation",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Generalized Assignment Problem</span>"
    ]
  },
  {
    "objectID": "lagrange-assignment.html#implementation",
    "href": "lagrange-assignment.html#implementation",
    "title": "5  Generalized Assignment Problem",
    "section": "5.3 Implementation",
    "text": "5.3 Implementation\nOptimization is fun, especially when we turn our curated models and algorithms into computer codes using our favorite programming languages. In this section, we will solve some GAP instances using Lagrangian Relaxation!\n\n5.3.1 Benchmarking instances\nAll the benchmarking instances we solve here are taken from the OR-Library. There are a total of 16 data files, among which the first 12 data files are gap1, gap2, …, gap12, and the remaining 4 data files are gapa, gapb, gapc and gapd.\nAll the data files are formatted as follows:\n\nThe total number of problem instances in the data set (\\(P\\))\nFor each problem set \\(p\\) (\\(p = 1,...,P\\)) in turn:\n\nThe number of agents (\\(m\\)), number of tasks (\\(n\\))\nFor each agent \\(i\\) (\\(i = 1,...,m\\)) in turn:\n\nThe cost of allocating task \\(j\\) to agent \\(i\\) (\\(j = 1,...,n\\))\n\nFor each agent \\(i\\) (\\(i = 1,...,m\\)) in turn:\n\nThe resource consumed in allocating task \\(j\\) to agent \\(i\\) (\\(j = 1,...,n\\))\n\nThe resource capacity of agent \\(i\\) (\\(i = 1,...,m\\))\n\n\nSince we have the luxury of unlimited space in this online book, I will show the full content of the data file gap1.txt. This file contains 5 GAP instances and all of them have the same number of agents (5) and tasks (15).\n\n\ngap1.txt\n\n 5\n 5 15\n 17 21 22 18 24 15 20 18 19 18 16 22 24 24 16\n 23 16 21 16 17 16 19 25 18 21 17 15 25 17 24\n 16 20 16 25 24 16 17 19 19 18 20 16 17 21 24\n 19 19 22 22 20 16 19 17 21 19 25 23 25 25 25\n 18 19 15 15 21 25 16 16 23 15 22 17 19 22 24\n 8 15 14 23 8 16 8 25 9 17 25 15 10 8 24\n 15 7 23 22 11 11 12 10 17 16 7 16 10 18 22\n 21 20 6 22 24 10 24 9 21 14 11 14 11 19 16\n 20 11 8 14 9 5 6 19 19 7 6 6 13 9 18\n 8 13 13 13 10 20 25 16 16 17 10 10 5 12 23\n 36 34 38 27 33\n 5 15\n 19 23 24 20 20 25 16 21 24 15 17 17 20 20 20\n 25 24 16 21 19 17 17 19 23 21 21 23 20 15 16\n 16 21 25 22 24 24 16 17 15 18 15 17 18 24 18\n 25 24 18 19 15 18 20 22 23 18 16 19 17 15 22\n 25 19 21 22 20 15 20 19 18 18 17 23 17 25 25\n 16 12 8 20 18 10 12 8 14 23 19 14 15 15 24\n 16 18 19 22 13 20 9 7 25 10 20 13 11 15 16\n 6 20 20 5 14 12 6 15 22 18 13 23 23 18 25\n 18 23 25 17 25 13 23 23 13 20 20 23 17 19 24\n 12 17 15 25 22 5 24 19 12 25 23 21 23 19 18\n 36 37 38 48 44\n 5 15\n 22 21 16 17 21 15 17 22 22 25 18 20 24 15 22\n 23 24 19 15 16 21 15 25 16 21 20 19 16 23 20\n 21 20 21 25 21 20 21 19 17 16 25 19 15 15 15\n 17 21 25 25 23 22 20 19 20 25 15 20 21 25 23\n 15 25 23 19 17 17 25 24 24 17 24 19 18 19 16\n 23 10 15 13 17 10 13 6 9 21 20 7 9 25 8\n 17 13 8 23 11 18 7 22 13 5 24 24 15 10 22\n 22 17 22 23 20 11 17 25 23 9 22 20 15 9 25\n 5 19 25 16 15 10 18 9 11 20 7 21 15 8 25\n 22 9 10 23 19 21 17 15 15 17 25 19 10 9 21\n 32 37 44 35 40\n 5 15\n 15 25 20 18 19 21 18 22 24 15 25 17 17 15 22\n 20 18 25 25 16 24 22 24 17 18 23 25 21 25 24\n 25 19 18 18 23 18 15 22 23 16 25 22 22 15 16\n 19 19 23 17 19 19 22 19 23 22 24 22 25 19 16\n 25 24 17 19 25 19 23 19 25 15 19 21 18 19 22\n 20 20 18 9 18 5 16 18 13 24 21 23 15 19 9\n 5 12 18 8 22 19 19 11 7 19 20 17 21 25 5\n 18 8 8 9 20 20 23 13 15 12 6 12 25 25 23\n 17 19 24 9 16 22 10 17 12 17 15 21 16 18 6\n 14 6 20 6 21 5 11 23 20 21 20 18 13 13 21\n 39 36 37 38 37\n 5 15\n 25 25 18 24 20 19 25 24 23 15 18 18 25 15 22\n 25 18 17 22 21 23 20 23 16 19 15 18 16 23 16\n 18 16 19 15 15 18 15 20 19 24 22 20 25 16 21\n 18 21 16 18 17 24 18 23 22 16 17 22 22 18 16\n 17 18 15 21 23 21 24 23 20 22 19 15 22 22 25\n 16 20 9 22 17 19 20 22 20 13 6 20 23 19 7\n 12 22 18 18 6 13 17 17 17 14 20 12 17 14 22\n 5 19 19 14 24 16 7 8 9 22 13 23 24 15 20\n 20 8 6 9 5 17 23 18 14 12 14 17 15 23 21\n 6 6 24 24 8 7 5 25 21 18 12 20 20 7 12\n 40 38 38 35 34\n\nListing 5.1 shows the python code that reads in all the instances from a data file and saves them into a Python list.\n\n\n\n\nListing 5.1: File reading function\n\n\ndef read_instance_file(file_path):\n    instances = []\n\n    with open(file_path, 'r') as file:\n        num_instances = int(file.readline().strip())\n\n        for _ in range(num_instances):\n            num_agents, num_tasks = map(int, file.readline().split())\n\n            costs = []\n            for _ in range(num_agents):\n                costs.append(list(map(int, file.readline().split())))\n\n            resources = []\n            for _ in range(num_agents):\n                resources.append(list(map(int, file.readline().split())))\n\n            capacities = list(map(int, file.readline().split()))\n\n            instance = {\n                'num_agents': num_agents,\n                'num_tasks': num_tasks,\n                'costs': costs,\n                'resources': resources,\n                'capacities': capacities\n            }\n            instances.append(instance)\n\n    return num_instances, instances\n\n\n\n\nBelow we read the data file ‘gap1.txt’ and display the first instance.\n\n# Example usage:\nfile_path = '/Users/klian/dev/books/large-scale-opt-python/data/gap/gap1.txt'  # Replace with the actual file path\nnum_instances, instances = read_instance_file(file_path)\ninstance = instances[0]\nprint(f'num_instances: {num_instances}')\nprint(f\"num_agents: {instance['num_agents']}\")\nprint(f\"num_tasks: {instance['num_tasks']}\")\n\nnum_instances: 5\nnum_agents: 5\nnum_tasks: 15\n\n\n\ninstance['costs']\n\n[[17, 21, 22, 18, 24, 15, 20, 18, 19, 18, 16, 22, 24, 24, 16],\n [23, 16, 21, 16, 17, 16, 19, 25, 18, 21, 17, 15, 25, 17, 24],\n [16, 20, 16, 25, 24, 16, 17, 19, 19, 18, 20, 16, 17, 21, 24],\n [19, 19, 22, 22, 20, 16, 19, 17, 21, 19, 25, 23, 25, 25, 25],\n [18, 19, 15, 15, 21, 25, 16, 16, 23, 15, 22, 17, 19, 22, 24]]\n\n\n\ninstance['resources']\n\n[[8, 15, 14, 23, 8, 16, 8, 25, 9, 17, 25, 15, 10, 8, 24],\n [15, 7, 23, 22, 11, 11, 12, 10, 17, 16, 7, 16, 10, 18, 22],\n [21, 20, 6, 22, 24, 10, 24, 9, 21, 14, 11, 14, 11, 19, 16],\n [20, 11, 8, 14, 9, 5, 6, 19, 19, 7, 6, 6, 13, 9, 18],\n [8, 13, 13, 13, 10, 20, 25, 16, 16, 17, 10, 10, 5, 12, 23]]\n\n\n\ninstance['capacities']\n\n[36, 34, 38, 27, 33]\n\n\n\n\n5.3.2 Solve the original problem\nIn this section, we use SCIP to solve the original formulation of the GAP, which is given in Listing 5.3.\n\n\n\n\nListing 5.2: SCIP solver for GAP\n\n\nimport pyscipopt as scip\nfrom pyscipopt import SCIP_PARAMSETTING\n\nclass ScipGapSolver:\n    \n    def __init__(self, instance):\n        self._instance = instance\n        self._model = scip.Model(\"GAP solver\")\n        self._vars = None\n    \n    def build_model(self):\n        # create decision variables\n        self._vars = {\n            (i, j): self._model.addVar(f\"x_{i},{j}\", vtype='B')\n            for i in range(self._instance['num_tasks'])\n            for j in range(self._instance['num_agents'])\n        }\n        \n        # create objective\n        obj_expr = [\n            self._instance['costs'][j][i] * self._vars[(i, j)]\n            for i in range(self._instance['num_tasks'])\n            for j in range(self._instance['num_agents'])\n        ]\n        self._model.setObjective(scip.quicksum(obj_expr), \"minimize\")\n        \n        # create constraints\n        for i in range(self._instance['num_tasks']):\n            expr = [\n                self._vars[(i, j)]\n                for j in range(self._instance['num_agents'])\n            ]\n            self._model.addCons(scip.quicksum(expr) == 1)\n            \n        for j in range(self._instance['num_agents']):\n            expr = [\n                self._instance['resources'][j][i] * self._vars[(i, j)]\n            for i in range(self._instance['num_tasks'])\n            ]\n            self._model.addCons(scip.quicksum(expr) &lt;= self._instance['capacities'][j])\n    \n    def solve(self):\n        self._model.hideOutput()\n        self._model.optimize()\n        status = self._model.getStatus()\n        if status == \"optimal\":\n            print(f'Optimal solution found!')\n            print(f'Optimal objective = {self._model.getObjVal():.2f}')\n        elif status == \"unbounded\":\n            print(f'Model is unbounded!')\n        elif status == \"infeasible\":\n            print(f'Model is infeasible!')\n        else:\n            print(f'Unknown error occurred!')\n\n\n\n\n\nscip_gap_solver = ScipGapSolver(instance=instances[0])\nscip_gap_solver.build_model()\nscip_gap_solver.solve()\n\nOptimal solution found!\nOptimal objective = 254.36\n\n\n\n\n5.3.3 Solve the Lagrangian relaxation with fixed multipliers\n\n\n\n\nListing 5.3: SCIP solver for GAP\n\n\nfrom typing import List\nimport numpy as np\nimport pyscipopt as scip\nfrom pyscipopt import quicksum, SCIP_PARAMSETTING\n\nclass ScipGapLRSolver:\n    \n    def __init__(self, instance):\n        self._instance = instance\n        self._model = scip.Model(\"GAP Lagrangian relaxation solver\")\n        self._model.setBoolParam(\"reoptimization/enable\", True)\n        self._lagrange_multipliers = None\n        self._vars = None\n        \n        self._opt_vals = None\n    \n    def build_model(self, lagrange_multipliers: List):\n        # create decision variables\n        self._vars = {\n            (i, j): self._model.addVar(f\"x_{i},{j}\", vtype='BINARY')\n            for i in range(self._instance['num_tasks'])\n            for j in range(self._instance['num_agents'])\n        }\n        \n        # create objective\n        self._lagrange_multipliers = lagrange_multipliers\n        obj_expr = [\n            (self._instance['costs'][j][i] + self._lagrange_multipliers[i]) * self._vars[(i, j)]\n            for i in range(self._instance['num_tasks'])\n            for j in range(self._instance['num_agents'])\n        ]\n        self._model.setObjective(quicksum(obj_expr) - quicksum(self._lagrange_multipliers), \"minimize\") \n        \n        # create constraints        \n        for j in range(self._instance['num_agents']):\n            expr = [\n                self._instance['resources'][j][i] * self._vars[(i, j)]\n                for i in range(self._instance['num_tasks'])\n            ]\n            self._model.addCons(quicksum(expr) &lt;= self._instance['capacities'][j])    \n        \n    def solve(self):\n        self._model.hideOutput()\n        self._model.optimize()\n        status = self._model.getStatus()\n        if status == \"optimal\":\n            print(f'Optimal solution found!')\n            print(f'Optimal objective = {self._model.getObjVal():.2f}')\n            \n            self._opt_vals = {\n                (i, j): int(self._model.getVal(self._vars[(i, j)]))\n                for i in range(self._instance['num_tasks'])\n                for j in range(self._instance['num_agents'])\n            }\n        elif status == \"unbounded\":\n            print(f'Model is unbounded!')\n        elif status == \"infeasible\":\n            print(f'Model is infeasible!')\n        else:\n            print(f'Unknown error occurred!')\n            \n    def are_relaxed_constraints_violated(self) -&gt; bool:\n        \"\"\"check if the chosen relaxed constraints are violated in \n        the optimal solution.\n\n        Returns:\n            bool: true if violated, false otherwise\n        \"\"\"\n        for i in range(self._instance['num_tasks']):\n            total_assignments = np.sum([\n                self._opt_vals[(i, j)]\n                for j in range(self._instance['num_agents'])\n            ])\n            if total_assignments != 1:\n                return True\n        return False\n    \n    def get_original_obj_val(self):\n        orig_obj = np.sum([\n            self._instance['costs'][j][i] * self._opt_vals[(i, j)]\n            for i in range(self._instance['num_tasks'])\n            for j in range(self._instance['num_agents'])\n        ])\n        return orig_obj\n    \n    def get_constraint_violations(self):\n        violations = [\n            np.sum([\n                self._opt_vals[(i, j)]\n                for j in range(self._instance['num_agents'])\n            ]) - 1\n            for i in range(self._instance['num_tasks'])\n        ]\n        return violations\n    \n    def get_slackness(self) -&gt; List:\n        violations = self.get_constraint_violations()\n        slackness = np.sum(np.array(violations) * np.array(self._lagrange_multipliers))\n        return slackness\n    \n    @property\n    def opt_obj(self):\n        return self._model.getObjVal()\n            \n    @property\n    def opt_vals(self):\n        return self._opt_vals\n\n\n\n\n\nlagrange_multipliers = [0] * instances[0]['num_tasks']\nscip_gap_lr_solver = ScipGapLRSolver(instances[0])\nscip_gap_lr_solver.build_model(lagrange_multipliers)\nscip_gap_lr_solver.solve()\n\nOptimal solution found!\nOptimal objective = 0.00\n\n\n\nlagrange_multipliers = np.random.uniform(-5, 0, instances[0]['num_tasks'])\nscip_gap_lr_solver = ScipGapLRSolver(instances[0])\nscip_gap_lr_solver.build_model(lagrange_multipliers)\nscip_gap_lr_solver.solve()\n\nOptimal solution found!\nOptimal objective = 44.68\n\n\n\nlagrange_multipliers\n\narray([-3.79087264, -4.10340655, -4.45735867, -2.4412109 , -0.67257968,\n       -4.03323389, -3.72884933, -3.15312868, -2.76355069, -3.53444953,\n       -3.46946741, -0.51239749, -3.86990811, -1.03888481, -3.1140349 ])\n\n\n\n\n5.3.4 Approximating the best Lagrange multipliers\n\n5.3.4.1 Subgradient Search\n\nimport numpy as np\n\nclass ScipGapSubgradientSearch:\n    \n    def __init__(self, instance):\n        self._instance = instance\n        self._lr_solver = None\n        \n    def solve(self):\n        iter = 0\n        lb = -np.inf\n        ub = np.inf\n        eps = 1.0e-4\n        maxIter = 200\n        best_bound = 254.36\n        gamma = 0.9\n        \n        num_tasks = self._instance['num_tasks']\n        # multipliers = np.random.uniform(-30, -10, num_tasks)\n        multipliers = np.zeros(num_tasks)\n        \n        while True:\n            print(f'iter: {iter}')\n            print(f'multipliers: {multipliers}')\n            # solve relaxation with given multipliers\n            self._lr_solver = ScipGapLRSolver(self._instance)\n            self._lr_solver.build_model(multipliers)\n            self._lr_solver.solve()\n            \n            # update bounds\n            opt_obj = self._lr_solver.opt_obj\n            if opt_obj &gt; lb:\n                lb = opt_obj\n                print(f'lb updated, new lb: {lb}')\n                \n            constraints_violated = self._lr_solver.are_relaxed_constraints_violated()\n            print(f'constraints violation: {constraints_violated}')\n            if not constraints_violated:\n                orig_obj = self._lr_solver.get_original_obj_val()\n                if orig_obj &lt; ub:\n                    ub = orig_obj\n                    print(f'ub updated, new ub: {ub}')\n                \n            \n            # check stopping criteria\n            slackness = self._lr_solver.get_slackness()\n            print(f'slack: {slackness}')\n            if not constraints_violated:\n                if np.sum(slackness) &lt; eps:\n                    break\n            if iter &gt;= maxIter:\n                break\n            \n            # update multipliers\n            violations = self._lr_solver.get_constraint_violations()\n            relaxed_obj = self._lr_solver.opt_obj\n            step_size = gamma * (best_bound - relaxed_obj) / (np.linalg.norm(violations))**2\n            multipliers += step_size * np.array(violations)\n            \n            iter += 1\n\n\napproximator = ScipGapSubgradientSearch(instances[0])\napproximator.solve()\n\niter: 0\nmultipliers: [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]\nOptimal solution found!\nOptimal objective = 0.00\nlb updated, new lb: 0.0\nconstraints violation: True\nslack: 0.0\niter: 1\nmultipliers: [-15.2616 -15.2616 -15.2616 -15.2616 -15.2616 -15.2616 -15.2616 -15.2616\n -15.2616 -15.2616 -15.2616 -15.2616 -15.2616 -15.2616 -15.2616]\nOptimal solution found!\nOptimal objective = 227.88\nlb updated, new lb: 227.87759999999997\nconstraints violation: True\nslack: 167.87759999999997\niter: 2\nmultipliers: [-17.42834182 -17.42834182 -15.2616     -15.2616     -17.42834182\n -15.2616     -17.42834182 -17.42834182 -17.42834182 -17.42834182\n -17.42834182 -15.2616     -17.42834182 -17.42834182 -17.42834182]\nOptimal solution found!\nOptimal objective = 242.47\nlb updated, new lb: 242.47474181818183\nconstraints violation: True\nslack: 78.47474181818181\niter: 3\nmultipliers: [-16.239816   -17.42834182 -16.45012582 -16.45012582 -17.42834182\n -16.45012582 -18.61686764 -16.239816   -18.61686764 -17.42834182\n -17.42834182 -16.45012582 -17.42834182 -18.61686764 -17.42834182]\nOptimal solution found!\nOptimal objective = 247.38\nlb updated, new lb: 247.38152509090907\nconstraints violation: True\nslack: 119.83165090909092\niter: 4\nmultipliers: [-16.93766349 -17.42834182 -16.45012582 -17.14797331 -18.12618931\n -15.75227833 -18.61686764 -16.93766349 -19.31471513 -17.42834182\n -17.42834182 -17.14797331 -18.12618931 -18.61686764 -18.12618931]\nOptimal solution found!\nOptimal objective = 249.10\nlb updated, new lb: 249.10115658181823\nconstraints violation: True\nslack: 103.10115658181819\niter: 5\nmultipliers: [-17.52928338 -17.42834182 -17.0417457  -17.14797331 -18.12618931\n -16.34389821 -18.61686764 -17.52928338 -19.31471513 -17.42834182\n -18.0199617  -16.55635342 -18.71780919 -19.20848752 -18.12618931]\nOptimal solution found!\nOptimal objective = 250.08\nlb updated, new lb: 250.08484212181824\nconstraints violation: True\nslack: 55.0848421218182\niter: 6\nmultipliers: [-16.75975496 -17.42834182 -17.0417457  -17.14797331 -18.89571773\n -16.34389821 -19.38639605 -17.52928338 -20.08424355 -17.42834182\n -18.0199617  -17.32588184 -18.71780919 -19.20848752 -18.12618931]\nOptimal solution found!\nOptimal objective = 250.99\nlb updated, new lb: 250.98745204112734\nconstraints violation: True\nslack: 67.98745204112727\niter: 7\nmultipliers: [-17.26563715 -17.42834182 -17.5476279  -17.14797331 -18.89571773\n -16.84978041 -18.88051386 -17.52928338 -20.08424355 -17.42834182\n -18.5258439  -17.32588184 -18.71780919 -19.71436971 -18.12618931]\nOptimal solution found!\nOptimal objective = 251.16\nlb updated, new lb: 251.16367152718738\nconstraints violation: True\nslack: 91.38527109696912\niter: 8\nmultipliers: [-17.58527    -17.74797467 -17.22799505 -17.46760616 -19.21535057\n -16.84978041 -19.20014671 -17.52928338 -20.08424355 -17.42834182\n -18.20621105 -17.32588184 -18.71780919 -20.03400256 -18.44582216]\nOptimal solution found!\nOptimal objective = 252.44\nlb updated, new lb: 252.44036031918495\nconstraints violation: True\nslack: 57.44036031918489\niter: 9\nmultipliers: [-17.58527    -17.74797467 -17.22799505 -17.46760616 -19.21535057\n -16.84978041 -19.77603861 -17.52928338 -20.08424355 -17.42834182\n -18.78210295 -17.32588184 -18.71780919 -20.60989447 -18.44582216]\nOptimal solution found!\nOptimal objective = 252.73\nlb updated, new lb: 252.73423499536844\nconstraints violation: True\nslack: 53.73423499536837\niter: 10\nmultipliers: [-17.58527    -17.74797467 -17.22799505 -17.46760616 -19.50798828\n -16.84978041 -19.77603861 -17.82192108 -20.08424355 -17.42834182\n -18.48946525 -17.61851954 -18.71780919 -20.60989447 -18.73845986]\nOptimal solution found!\nOptimal objective = 253.84\nlb updated, new lb: 253.84214878612696\nconstraints violation: True\nslack: 76.0701438354038\niter: 11\nmultipliers: [-17.66294768 -17.74797467 -17.30567273 -17.46760616 -19.50798828\n -16.84978041 -19.85371629 -17.82192108 -20.08424355 -17.42834182\n -18.56714293 -17.54084186 -18.71780919 -20.68757215 -18.73845986]\nOptimal solution found!\nOptimal objective = 253.87\nlb updated, new lb: 253.87075121293768\nconstraints violation: True\nslack: 54.87075121293772\niter: 12\nmultipliers: [-17.66294768 -17.74797467 -17.30567273 -17.46760616 -19.65476291\n -16.84978041 -19.85371629 -17.96869571 -20.08424355 -17.42834182\n -18.56714293 -17.6876165  -18.71780919 -20.68757215 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.08\nlb updated, new lb: 254.07982667184987\nconstraints violation: True\nslack: 56.07982667184986\niter: 13\nmultipliers: [-17.71337888 -17.74797467 -17.30567273 -17.46760616 -19.65476291\n -16.9002116  -19.85371629 -17.96869571 -20.08424355 -17.42834182\n -18.61757413 -17.6371853  -18.71780919 -20.73800335 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.15\nlb updated, new lb: 254.1456645040321\nconstraints violation: True\nslack: 57.14566450403207\niter: 14\nmultipliers: [-17.71337888 -17.74797467 -17.30567273 -17.46760616 -19.71906356\n -16.9002116  -19.91801694 -17.96869571 -20.08424355 -17.42834182\n -18.61757413 -17.70148595 -18.71780919 -20.73800335 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.26\nlb updated, new lb: 254.25578908596557\nconstraints violation: True\nslack: 93.72282731161633\niter: 15\nmultipliers: [-17.71337888 -17.76673263 -17.30567273 -17.46760616 -19.73782152\n -16.91896957 -19.91801694 -17.96869571 -20.08424355 -17.42834182\n -18.6363321  -17.70148595 -18.71780919 -20.75676131 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.31\nlb updated, new lb: 254.31111035330443\nconstraints violation: True\nslack: 59.31111035330446\niter: 16\nmultipliers: [-17.71337888 -17.76673263 -17.30567273 -17.46760616 -19.73782152\n -16.91896957 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65099899 -17.70148595 -18.71780919 -20.77142821 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.34\nlb updated, new lb: 254.3413967675614\nconstraints violation: True\nslack: 93.84595092226466\niter: 17\nmultipliers: [-17.71337888 -17.77008121 -17.30567273 -17.46760616 -19.74117011\n -16.92231815 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65434757 -17.70148595 -18.71780919 -20.77477679 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.35\nlb updated, new lb: 254.35144251307835\nconstraints violation: True\nslack: 93.86269383145941\niter: 18\nmultipliers: [-17.71337888 -17.77162156 -17.30567273 -17.46760616 -19.74271045\n -16.9238585  -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65588792 -17.70148595 -18.71780919 -20.77631714 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nlb updated, new lb: 254.35606355601604\nconstraints violation: True\nslack: 93.87039556968891\niter: 19\nmultipliers: [-17.71337888 -17.77233012 -17.30567273 -17.46760616 -19.74341901\n -16.92456706 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65659648 -17.70148595 -18.71780919 -20.7770257  -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nlb updated, new lb: 254.3581892357673\nconstraints violation: True\nslack: 93.87393836927448\niter: 20\nmultipliers: [-17.71337888 -17.77265606 -17.30567273 -17.46760616 -19.74374495\n -16.924893   -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65692242 -17.70148595 -18.71780919 -20.77735163 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nlb updated, new lb: 254.3591670484531\nconstraints violation: True\nslack: 93.87556805708394\niter: 21\nmultipliers: [-17.71337888 -17.77280599 -17.30567273 -17.46760616 -19.74389488\n -16.92504293 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65707235 -17.70148595 -18.71780919 -20.77750156 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nlb updated, new lb: 254.35961684228832\nconstraints violation: True\nslack: 93.87631771347617\niter: 22\nmultipliers: [-17.71337888 -17.77287496 -17.30567273 -17.46760616 -19.74396385\n -16.9251119  -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65714132 -17.70148595 -18.71780919 -20.77757053 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nlb updated, new lb: 254.35982374745274\nconstraints violation: True\nslack: 93.87666255541671\niter: 23\nmultipliers: [-17.71337888 -17.77290668 -17.30567273 -17.46760616 -19.74399558\n -16.92514362 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65717304 -17.70148595 -18.71780919 -20.77760226 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nlb updated, new lb: 254.3599189238282\nconstraints violation: True\nslack: 93.87682118270925\niter: 24\nmultipliers: [-17.71337888 -17.77292128 -17.30567273 -17.46760616 -19.74401017\n -16.92515822 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65718764 -17.70148595 -18.71780919 -20.77761685 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nlb updated, new lb: 254.35996270496096\nconstraints violation: True\nslack: 93.8768941512639\niter: 25\nmultipliers: [-17.71337888 -17.77292799 -17.30567273 -17.46760616 -19.74401688\n -16.92516493 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65719435 -17.70148595 -18.71780919 -20.77762356 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nlb updated, new lb: 254.35998284428214\nconstraints violation: True\nslack: 93.87692771679906\niter: 26\nmultipliers: [-17.71337888 -17.77293108 -17.30567273 -17.46760616 -19.74401997\n -16.92516802 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65719744 -17.70148595 -18.71780919 -20.77762665 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nlb updated, new lb: 254.3599921083697\nconstraints violation: True\nslack: 93.87694315694515\niter: 27\nmultipliers: [-17.71337888 -17.7729325  -17.30567273 -17.46760616 -19.74402139\n -16.92516944 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65719886 -17.70148595 -18.71780919 -20.77762807 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nlb updated, new lb: 254.3599963698501\nconstraints violation: True\nslack: 93.87695025941241\niter: 28\nmultipliers: [-17.71337888 -17.77293315 -17.30567273 -17.46760616 -19.74402205\n -16.92517009 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65719951 -17.70148595 -18.71780919 -20.77762873 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nlb updated, new lb: 254.3599983301311\nconstraints violation: True\nslack: 93.87695352654733\niter: 29\nmultipliers: [-17.71337888 -17.77293345 -17.30567273 -17.46760616 -19.74402235\n -16.92517039 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65719981 -17.70148595 -18.71780919 -20.77762903 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nlb updated, new lb: 254.35999923186031\nconstraints violation: True\nslack: 93.87695502942934\niter: 30\nmultipliers: [-17.71337888 -17.77293359 -17.30567273 -17.46760616 -19.74402248\n -16.92517053 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65719995 -17.70148595 -18.71780919 -20.77762917 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nlb updated, new lb: 254.35999964665572\nconstraints violation: True\nslack: 93.87695572075508\niter: 31\nmultipliers: [-17.71337888 -17.77293365 -17.30567273 -17.46760616 -19.74402255\n -16.92517059 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720002 -17.70148595 -18.71780919 -20.77762923 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nlb updated, new lb: 254.35999983746163\nconstraints violation: True\nslack: 93.87695603876494\niter: 32\nmultipliers: [-17.71337888 -17.77293368 -17.30567273 -17.46760616 -19.74402258\n -16.92517062 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720004 -17.70148595 -18.71780919 -20.77762926 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nlb updated, new lb: 254.35999992523236\nconstraints violation: True\nslack: 93.8769561850495\niter: 33\nmultipliers: [-17.71337888 -17.7729337  -17.30567273 -17.46760616 -19.74402259\n -16.92517064 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720006 -17.70148595 -18.71780919 -20.77762927 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nlb updated, new lb: 254.35999996560687\nconstraints violation: True\nslack: 93.87695625234038\niter: 34\nmultipliers: [-17.71337888 -17.7729337  -17.30567273 -17.46760616 -19.7440226\n -16.92517064 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720006 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nlb updated, new lb: 254.35999998417915\nconstraints violation: True\nslack: 93.87695628329419\niter: 35\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517064 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nlb updated, new lb: 254.3599999927225\nconstraints violation: True\nslack: 93.87695629753297\niter: 36\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nlb updated, new lb: 254.3599999966523\nconstraints violation: True\nslack: 93.87695630408274\niter: 37\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nlb updated, new lb: 254.35999999846004\nconstraints violation: True\nslack: 93.87695630709567\niter: 38\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nlb updated, new lb: 254.35999999929172\nconstraints violation: True\nslack: 93.87695630848165\niter: 39\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nlb updated, new lb: 254.35999999967416\nconstraints violation: True\nslack: 93.87695630911911\niter: 40\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nlb updated, new lb: 254.35999999985015\nconstraints violation: True\nslack: 93.87695630941239\niter: 41\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nlb updated, new lb: 254.35999999993098\nconstraints violation: True\nslack: 93.87695630954727\niter: 42\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nlb updated, new lb: 254.35999999996832\nconstraints violation: True\nslack: 93.87695630960941\niter: 43\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nlb updated, new lb: 254.35999999998538\nconstraints violation: True\nslack: 93.87695630963793\niter: 44\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nlb updated, new lb: 254.35999999999333\nconstraints violation: True\nslack: 93.87695630965112\niter: 45\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nlb updated, new lb: 254.35999999999697\nconstraints violation: True\nslack: 93.87695630965712\niter: 46\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nlb updated, new lb: 254.3599999999985\nconstraints violation: True\nslack: 93.87695630965986\niter: 47\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nlb updated, new lb: 254.35999999999936\nconstraints violation: True\nslack: 93.87695630966121\niter: 48\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nlb updated, new lb: 254.3599999999997\nconstraints violation: True\nslack: 93.8769563096618\niter: 49\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nlb updated, new lb: 254.35999999999987\nconstraints violation: True\nslack: 93.87695630966208\niter: 50\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nlb updated, new lb: 254.35999999999999\nconstraints violation: True\nslack: 93.8769563096622\niter: 51\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nlb updated, new lb: 254.36000000000004\nconstraints violation: True\nslack: 93.87695630966222\niter: 52\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.8769563096622\niter: 53\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.87695630966222\niter: 54\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.8769563096622\niter: 55\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.87695630966222\niter: 56\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.8769563096622\niter: 57\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.87695630966222\niter: 58\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.8769563096622\niter: 59\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.87695630966222\niter: 60\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.8769563096622\niter: 61\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.87695630966222\niter: 62\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.8769563096622\niter: 63\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.87695630966222\niter: 64\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.8769563096622\niter: 65\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.87695630966222\niter: 66\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.8769563096622\niter: 67\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.87695630966222\niter: 68\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.8769563096622\niter: 69\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.87695630966222\niter: 70\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.8769563096622\niter: 71\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.87695630966222\niter: 72\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.8769563096622\niter: 73\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.87695630966222\niter: 74\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.8769563096622\niter: 75\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.87695630966222\niter: 76\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.8769563096622\niter: 77\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.87695630966222\niter: 78\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.8769563096622\niter: 79\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.87695630966222\niter: 80\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.8769563096622\niter: 81\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.87695630966222\niter: 82\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.8769563096622\niter: 83\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.87695630966222\niter: 84\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.8769563096622\niter: 85\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.87695630966222\niter: 86\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.8769563096622\niter: 87\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.87695630966222\niter: 88\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.8769563096622\niter: 89\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.87695630966222\niter: 90\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.8769563096622\niter: 91\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.87695630966222\niter: 92\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.8769563096622\niter: 93\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.87695630966222\niter: 94\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.8769563096622\niter: 95\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.87695630966222\niter: 96\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.8769563096622\niter: 97\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.87695630966222\niter: 98\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.8769563096622\niter: 99\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.87695630966222\niter: 100\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.8769563096622\niter: 101\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.87695630966222\niter: 102\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.8769563096622\niter: 103\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.87695630966222\niter: 104\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.8769563096622\niter: 105\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.87695630966222\niter: 106\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.8769563096622\niter: 107\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.87695630966222\niter: 108\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.8769563096622\niter: 109\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.87695630966222\niter: 110\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.8769563096622\niter: 111\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.87695630966222\niter: 112\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.8769563096622\niter: 113\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.87695630966222\niter: 114\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.8769563096622\niter: 115\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.87695630966222\niter: 116\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.8769563096622\niter: 117\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.87695630966222\niter: 118\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.8769563096622\niter: 119\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.87695630966222\niter: 120\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.8769563096622\niter: 121\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.87695630966222\niter: 122\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.8769563096622\niter: 123\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.87695630966222\niter: 124\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.8769563096622\niter: 125\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.87695630966222\niter: 126\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.8769563096622\niter: 127\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.87695630966222\niter: 128\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.8769563096622\niter: 129\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.87695630966222\niter: 130\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.8769563096622\niter: 131\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.87695630966222\niter: 132\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.8769563096622\niter: 133\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.87695630966222\niter: 134\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.8769563096622\niter: 135\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.87695630966222\niter: 136\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.8769563096622\niter: 137\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.87695630966222\niter: 138\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.8769563096622\niter: 139\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.87695630966222\niter: 140\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.8769563096622\niter: 141\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.87695630966222\niter: 142\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.8769563096622\niter: 143\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.87695630966222\niter: 144\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.8769563096622\niter: 145\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.87695630966222\niter: 146\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.8769563096622\niter: 147\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.87695630966222\niter: 148\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.8769563096622\niter: 149\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.87695630966222\niter: 150\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.8769563096622\niter: 151\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.87695630966222\niter: 152\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.8769563096622\niter: 153\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.87695630966222\niter: 154\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.8769563096622\niter: 155\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.87695630966222\niter: 156\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.8769563096622\niter: 157\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.87695630966222\niter: 158\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.8769563096622\niter: 159\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.87695630966222\niter: 160\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.8769563096622\niter: 161\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.87695630966222\niter: 162\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.8769563096622\niter: 163\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.87695630966222\niter: 164\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.8769563096622\niter: 165\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.87695630966222\niter: 166\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.8769563096622\niter: 167\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.87695630966222\niter: 168\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.8769563096622\niter: 169\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.87695630966222\niter: 170\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.8769563096622\niter: 171\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.87695630966222\niter: 172\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.8769563096622\niter: 173\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.87695630966222\niter: 174\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.8769563096622\niter: 175\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.87695630966222\niter: 176\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.8769563096622\niter: 177\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.87695630966222\niter: 178\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.8769563096622\niter: 179\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.87695630966222\niter: 180\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.8769563096622\niter: 181\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.87695630966222\niter: 182\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.8769563096622\niter: 183\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.87695630966222\niter: 184\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.8769563096622\niter: 185\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.87695630966222\niter: 186\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.8769563096622\niter: 187\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.87695630966222\niter: 188\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.8769563096622\niter: 189\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.87695630966222\niter: 190\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.8769563096622\niter: 191\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.87695630966222\niter: 192\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.8769563096622\niter: 193\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.87695630966222\niter: 194\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.8769563096622\niter: 195\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.87695630966222\niter: 196\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.8769563096622\niter: 197\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.87695630966222\niter: 198\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.8769563096622\niter: 199\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.87695630966222\niter: 200\nmultipliers: [-17.71337888 -17.77293371 -17.30567273 -17.46760616 -19.7440226\n -16.92517065 -19.93268384 -17.96869571 -20.08424355 -17.42834182\n -18.65720007 -17.70148595 -18.71780919 -20.77762928 -18.73845986]\nOptimal solution found!\nOptimal objective = 254.36\nconstraints violation: True\nslack: 93.8769563096622\n\n\n\n\n5.3.4.2 Surrogate Subgradient Search",
    "crumbs": [
      "Lagrangian Relaxation",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Generalized Assignment Problem</span>"
    ]
  },
  {
    "objectID": "lagrange-assignment.html#alternative-relaxation",
    "href": "lagrange-assignment.html#alternative-relaxation",
    "title": "5  Generalized Assignment Problem",
    "section": "5.4 Alternative Relaxation",
    "text": "5.4 Alternative Relaxation",
    "crumbs": [
      "Lagrangian Relaxation",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Generalized Assignment Problem</span>"
    ]
  },
  {
    "objectID": "lagrange-assignment.html#performance-comparison",
    "href": "lagrange-assignment.html#performance-comparison",
    "title": "5  Generalized Assignment Problem",
    "section": "5.5 Performance Comparison",
    "text": "5.5 Performance Comparison",
    "crumbs": [
      "Lagrangian Relaxation",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Generalized Assignment Problem</span>"
    ]
  },
  {
    "objectID": "cg-theory.html",
    "href": "cg-theory.html",
    "title": "9  Column Generation Theories",
    "section": "",
    "text": "If I have to choose my favorite decomposition algorithm, column generation is the one!\nI have used column generation in several industry projects and it never failed to meet my needs. Unlike Benders decomposition or Lagrangian relaxation which transforms the original formulation in certain smart ways, column generation is more of a new modeling philosophy. It requires one to approach a problem through a different mindset and rise with a new formulation that enables efficient problem solving.",
    "crumbs": [
      "Column Generation",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Column Generation Theories</span>"
    ]
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "12  Summary",
    "section": "",
    "text": "In summary, this book has no content whatsoever.",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Summary</span>"
    ]
  }
]