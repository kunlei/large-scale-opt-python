[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Hands-on Large Scale Optimization in Python",
    "section": "",
    "text": "Preface"
  },
  {
    "objectID": "preface.html#install-homebrew",
    "href": "preface.html#install-homebrew",
    "title": "1  Environment Setup",
    "section": "1.1 Install Homebrew",
    "text": "1.1 Install Homebrew\nThe first tool we need is Homebrew, ‘the Missing Package Manager for macOS (or Linux)’, and it can be accessed at https://brew.sh/. To install Homebrew, just copy the command below and run it in the Terminal.\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\nWe can then use the brew --version command to check the installed version. On my system, it shows the info below.\n ~/ brew --version\nHomebrew 3.6.20\nHomebrew/homebrew-core (git revision 5f1582e4d55; last commit 2023-02-05)\nHomebrew/homebrew-cask (git revision fa3b8a669d; last commit 2023-02-05)"
  },
  {
    "objectID": "preface.html#install-anaconda",
    "href": "preface.html#install-anaconda",
    "title": "1  Environment Setup",
    "section": "1.2 Install Anaconda",
    "text": "1.2 Install Anaconda\nSince there are several Python versions available for our use and we may end up having multiple Python versions installed on our machine, it is important to use a consistent environment to work on our project in. Anaconda is a package and environment manager for Python and it provides easy-to-use tools to facilitate our data science needs. To install Anaconda, run the below command in the Terminal.\n ~/ brew install anaconda\nAfter the installation is done, we can use conda --version to verify whether it is available on our machine or not.\n ~/ conda --version\nconda 23.1.0"
  },
  {
    "objectID": "preface.html#create-a-conda-environment",
    "href": "preface.html#create-a-conda-environment",
    "title": "1  Environment Setup",
    "section": "1.3 Create a Conda Environment",
    "text": "1.3 Create a Conda Environment\nNow we will create a Conda environment named ‘ortools’. Execute the below command in the Terminal, which effectively creates the required environment with Python version 3.10.\n ~/ conda create -n ortools python=3.10\nRetrieving notices: ...working... done\nCollecting package metadata (current_repodata.json): done\nSolving environment: done\n\n## Package Plan ##\n\n  environment location: /opt/homebrew/anaconda3/envs/test\n\n  added / updated specs:\n    - python=3.10\n\n\nThe following packages will be downloaded:\n\n    package                    |            build\n    ---------------------------|-----------------\n    setuptools-67.4.0          |     pyhd8ed1ab_0         567 KB  conda-forge\n    ------------------------------------------------------------\n                                           Total:         567 KB\n\nThe following NEW packages will be INSTALLED:\n\n  bzip2              conda-forge/osx-arm64::bzip2-1.0.8-h3422bc3_4\n  ca-certificates    conda-forge/osx-arm64::ca-certificates-2022.12.7-h4653dfc_0\n  libffi             conda-forge/osx-arm64::libffi-3.4.2-h3422bc3_5\n  libsqlite          conda-forge/osx-arm64::libsqlite-3.40.0-h76d750c_0\n  libzlib            conda-forge/osx-arm64::libzlib-1.2.13-h03a7124_4\n  ncurses            conda-forge/osx-arm64::ncurses-6.3-h07bb92c_1\n  openssl            conda-forge/osx-arm64::openssl-3.0.8-h03a7124_0\n  pip                conda-forge/noarch::pip-23.0.1-pyhd8ed1ab_0\n  python             conda-forge/osx-arm64::python-3.10.9-h3ba56d0_0_cpython\n  readline           conda-forge/osx-arm64::readline-8.1.2-h46ed386_0\n  setuptools         conda-forge/noarch::setuptools-67.4.0-pyhd8ed1ab_0\n  tk                 conda-forge/osx-arm64::tk-8.6.12-he1e0b03_0\n  tzdata             conda-forge/noarch::tzdata-2022g-h191b570_0\n  wheel              conda-forge/noarch::wheel-0.38.4-pyhd8ed1ab_0\n  xz                 conda-forge/osx-arm64::xz-5.2.6-h57fd34a_0\n\n\nProceed ([y]/n)?\nType ‘y’ to proceed and Conda will create the environment for us. We can use cnoda env list to show all the created environments on our machine:\n ~/ conda env list\n# conda environments:\n#\nbase                     /opt/homebrew/anaconda3\nortools                   /opt/homebrew/anaconda3/envs/ortools\nNote that we need to manually activate an environemnt in order to use it: conda activate ortools. On my machine, the activated environment ortools will appear in the beginning of my prompt.\n ~/ conda activate ortools\n(ortools)  ~/"
  },
  {
    "objectID": "preface.html#install-google-or-tools",
    "href": "preface.html#install-google-or-tools",
    "title": "1  Environment Setup",
    "section": "1.4 Install Google OR-Tools",
    "text": "1.4 Install Google OR-Tools\nAs of this writing, the latest version of Google OR-Tools is 9.5.2237, and we can install it in our newly created environment using the command pip install ortools==9.5.2237. We can use conda list to verify whether it is available in our environment.\n(ortools)  ~/ conda list\n# packages in environment at /opt/homebrew/anaconda3/envs/ortools:\n#\n# Name                    Version                   Build  Channel\nabsl-py                   1.4.0                    pypi_0    pypi\nbzip2                     1.0.8                h3422bc3_4    conda-forge\nca-certificates           2022.12.7            h4653dfc_0    conda-forge\nlibffi                    3.4.2                h3422bc3_5    conda-forge\nlibsqlite                 3.40.0               h76d750c_0    conda-forge\nlibzlib                   1.2.13               h03a7124_4    conda-forge\nncurses                   6.3                  h07bb92c_1    conda-forge\nnumpy                     1.24.2                   pypi_0    pypi\nopenssl                   3.0.8                h03a7124_0    conda-forge\nortools                   9.5.2237                 pypi_0    pypi\npip                       23.0.1             pyhd8ed1ab_0    conda-forge\nprotobuf                  4.22.0                   pypi_0    pypi\npython                    3.10.9          h3ba56d0_0_cpython    conda-forge\nreadline                  8.1.2                h46ed386_0    conda-forge\nsetuptools                67.4.0             pyhd8ed1ab_0    conda-forge\ntk                        8.6.12               he1e0b03_0    conda-forge\ntzdata                    2022g                h191b570_0    conda-forge\nwheel                     0.38.4             pyhd8ed1ab_0    conda-forge\nxz                        5.2.6                h57fd34a_0    conda-forge\nNow we have Python and Google OR-Tools ready, we can start our next journey."
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "2  Introduction",
    "section": "",
    "text": "This is a book created from markdown and executable code.\nSee Knuth (1984) for additional discussion of literate programming.\n\n\n\n\nKnuth, Donald E. 1984. “Literate Programming.” Comput. J. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97."
  },
  {
    "objectID": "env-setup.html#install-homebrew",
    "href": "env-setup.html#install-homebrew",
    "title": "3  Environment Setup",
    "section": "3.1 Install Homebrew",
    "text": "3.1 Install Homebrew\nThe first tool we need is Homebrew, ‘the Missing Package Manager for macOS (or Linux)’, and it can be accessed at https://brew.sh/. To install Homebrew, just copy the command below and run it in the Terminal.\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\nWe can then use the brew --version command to check the installed version. On my system, it shows the info below.\n ~/ brew --version\nHomebrew 3.6.20\nHomebrew/homebrew-core (git revision 5f1582e4d55; last commit 2023-02-05)\nHomebrew/homebrew-cask (git revision fa3b8a669d; last commit 2023-02-05)"
  },
  {
    "objectID": "env-setup.html#install-anaconda",
    "href": "env-setup.html#install-anaconda",
    "title": "3  Environment Setup",
    "section": "3.2 Install Anaconda",
    "text": "3.2 Install Anaconda\nSince there are several Python versions available for our use and we may end up having multiple Python versions installed on our machine, it is important to use a consistent environment to work on our project in. Anaconda is a package and environment manager for Python and it provides easy-to-use tools to facilitate our data science needs. To install Anaconda, run the below command in the Terminal.\n ~/ brew install anaconda\nAfter the installation is done, we can use conda --version to verify whether it is available on our machine or not.\n ~/ conda --version\nconda 23.1.0"
  },
  {
    "objectID": "env-setup.html#create-a-conda-environment",
    "href": "env-setup.html#create-a-conda-environment",
    "title": "3  Environment Setup",
    "section": "3.3 Create a Conda Environment",
    "text": "3.3 Create a Conda Environment\nNow we will create a Conda environment named ‘ortools’. Execute the below command in the Terminal, which effectively creates the required environment with Python version 3.10.\n ~/ conda create -n ortools python=3.10\nRetrieving notices: ...working... done\nCollecting package metadata (current_repodata.json): done\nSolving environment: done\n\n## Package Plan ##\n\n  environment location: /opt/homebrew/anaconda3/envs/test\n\n  added / updated specs:\n    - python=3.10\n\n\nThe following packages will be downloaded:\n\n    package                    |            build\n    ---------------------------|-----------------\n    setuptools-67.4.0          |     pyhd8ed1ab_0         567 KB  conda-forge\n    ------------------------------------------------------------\n                                           Total:         567 KB\n\nThe following NEW packages will be INSTALLED:\n\n  bzip2              conda-forge/osx-arm64::bzip2-1.0.8-h3422bc3_4\n  ca-certificates    conda-forge/osx-arm64::ca-certificates-2022.12.7-h4653dfc_0\n  libffi             conda-forge/osx-arm64::libffi-3.4.2-h3422bc3_5\n  libsqlite          conda-forge/osx-arm64::libsqlite-3.40.0-h76d750c_0\n  libzlib            conda-forge/osx-arm64::libzlib-1.2.13-h03a7124_4\n  ncurses            conda-forge/osx-arm64::ncurses-6.3-h07bb92c_1\n  openssl            conda-forge/osx-arm64::openssl-3.0.8-h03a7124_0\n  pip                conda-forge/noarch::pip-23.0.1-pyhd8ed1ab_0\n  python             conda-forge/osx-arm64::python-3.10.9-h3ba56d0_0_cpython\n  readline           conda-forge/osx-arm64::readline-8.1.2-h46ed386_0\n  setuptools         conda-forge/noarch::setuptools-67.4.0-pyhd8ed1ab_0\n  tk                 conda-forge/osx-arm64::tk-8.6.12-he1e0b03_0\n  tzdata             conda-forge/noarch::tzdata-2022g-h191b570_0\n  wheel              conda-forge/noarch::wheel-0.38.4-pyhd8ed1ab_0\n  xz                 conda-forge/osx-arm64::xz-5.2.6-h57fd34a_0\n\n\nProceed ([y]/n)?\nType ‘y’ to proceed and Conda will create the environment for us. We can use cnoda env list to show all the created environments on our machine:\n ~/ conda env list\n# conda environments:\n#\nbase                     /opt/homebrew/anaconda3\nortools                   /opt/homebrew/anaconda3/envs/ortools\nNote that we need to manually activate an environemnt in order to use it: conda activate ortools. On my machine, the activated environment ortools will appear in the beginning of my prompt.\n ~/ conda activate ortools\n(ortools)  ~/"
  },
  {
    "objectID": "env-setup.html#install-google-or-tools",
    "href": "env-setup.html#install-google-or-tools",
    "title": "3  Environment Setup",
    "section": "3.4 Install Google OR-Tools",
    "text": "3.4 Install Google OR-Tools\nAs of this writing, the latest version of Google OR-Tools is 9.5.2237, and we can install it in our newly created environment using the command pip install ortools==9.5.2237. We can use conda list to verify whether it is available in our environment.\n(ortools)  ~/ conda list\n# packages in environment at /opt/homebrew/anaconda3/envs/ortools:\n#\n# Name                    Version                   Build  Channel\nabsl-py                   1.4.0                    pypi_0    pypi\nbzip2                     1.0.8                h3422bc3_4    conda-forge\nca-certificates           2022.12.7            h4653dfc_0    conda-forge\nlibffi                    3.4.2                h3422bc3_5    conda-forge\nlibsqlite                 3.40.0               h76d750c_0    conda-forge\nlibzlib                   1.2.13               h03a7124_4    conda-forge\nncurses                   6.3                  h07bb92c_1    conda-forge\nnumpy                     1.24.2                   pypi_0    pypi\nopenssl                   3.0.8                h03a7124_0    conda-forge\nortools                   9.5.2237                 pypi_0    pypi\npip                       23.0.1             pyhd8ed1ab_0    conda-forge\nprotobuf                  4.22.0                   pypi_0    pypi\npython                    3.10.9          h3ba56d0_0_cpython    conda-forge\nreadline                  8.1.2                h46ed386_0    conda-forge\nsetuptools                67.4.0             pyhd8ed1ab_0    conda-forge\ntk                        8.6.12               he1e0b03_0    conda-forge\ntzdata                    2022g                h191b570_0    conda-forge\nwheel                     0.38.4             pyhd8ed1ab_0    conda-forge\nxz                        5.2.6                h57fd34a_0    conda-forge\nNow we have Python and Google OR-Tools ready, we can start our next journey."
  },
  {
    "objectID": "benders-theory.html#the-decomposition-logic",
    "href": "benders-theory.html#the-decomposition-logic",
    "title": "4  Benders Decomposition",
    "section": "4.1 The Decomposition Logic",
    "text": "4.1 The Decomposition Logic\nTo explain the reasoning of Benders decomposition, let us look at the standard form of linear programming problems that involve two vector variables, \\(\\mathbf{x}\\) and \\(\\mathbf{y}\\). Let \\(p\\) and \\(q\\) indicate the dimensions of \\(\\mathbf{x}\\) and \\(\\mathbf{y}\\), respectively. Below is the original problem \\(\\mathbf{P}\\) we intend to solve.\n\\[\\begin{align}\n&(\\mathbf{P}) &\\quad \\text{min.} &\\quad \\mathbf{c}^T \\mathbf{x} + \\mathbf{f}^T \\mathbf{y} \\\\\n& &\\quad \\text{s.t.} &\\quad \\mathbf{A} \\mathbf{x} + \\mathbf{B} \\mathbf{y} = \\mathbf{b} \\\\\n& &\\quad &\\quad \\mathbf{x} \\geq 0, \\mathbf{y} \\geq 0\n\\end{align}\\]\nIn this formulation, \\(\\mathbf{c}\\) and \\(\\mathbf{f}\\) in the objective function represent the cost coefficients associated with decision variables \\(\\mathbf{x}\\) and \\(\\mathbf{y}\\), respectively. Both of them are column vectors of corresponding dimensions. In the constraints, matrix \\(\\mathbf{A}\\) is of dimension \\(m \\times p\\), and matrix \\(\\mathbf{B}\\) is of dimension \\(m \\times q\\). \\(\\mathbf{b}\\) is a column vector of dimension \\(m\\).\nSuppose the variable \\(\\mathbf{y}\\) is a complicating variable in the sense that the resulting problem is substantially easier to solve if the value of \\(\\mathbf{y}\\) is fixed. In this case, we could rewrite problem \\(\\mathbf{P}\\) as the following form:\n\\[\\begin{align}\n\\text{min.} &\\quad \\mathbf{f}^T \\mathbf{y} + g(\\mathbf{y}) \\\\\n\\text{s.t.} &\\quad \\mathbf{y} \\geq 0\n\\end{align}\\]\nwhere \\(g(\\mathbf{y})\\) is a function of \\(\\mathbf{y}\\) and is defined as the subproblem \\(\\mathbf{SP}\\) of the form below:\n\\[\\begin{align}\n&(\\mathbf{SP}) &\\quad \\text{min.} &\\quad \\mathbf{c}^T \\mathbf{x} \\\\\n& &\\quad \\text{s.t.} &\\quad \\mathbf{A} \\mathbf{x}  = \\mathbf{b} - \\mathbf{B} \\mathbf{y} \\label{bd-cons1} \\\\\n& &\\quad &\\quad \\mathbf{x} \\geq 0\n\\end{align}\\]\nNote that the \\(\\mathbf{y}\\) in constraint \\(\\eqref{bd-cons1}\\) takes on some known values when the problem is solved and the only decision variable in the above formulation is \\(\\mathbf{x}\\). The dual problem of \\(\\mathbf{SP}\\), \\(\\mathbf{DSP}\\), is given below.\n\\[\\begin{align}\n&(\\mathbf{DSP}) &\\quad \\text{max.} &\\quad (\\mathbf{b} - \\mathbf{B} \\mathbf{y})^{T} \\mathbf{u} \\\\\n& &\\quad \\text{s.t.} &\\quad \\mathbf{A}^T \\mathbf{u} \\leq \\mathbf{c} \\label{bd-cons2} \\\\\n& &\\quad &\\quad \\mathbf{u}\\  \\text{unrestricted}\n\\end{align}\\]\nA key characteristic of the above \\(\\mathbf{DSP}\\) is that its solution space does not depend on the value of \\(\\mathbf{y}\\), which only affects the objective function. According to the Minkowski’s representation theorem, any \\(\\bar{\\mathbf{u}}\\) satisfying the constraints \\(\\eqref{bd-cons2}\\) can be expressed as\n\\[\\begin{align}\n\\bar{\\mathbf{u}} = \\sum_{j \\in \\mathbf{J}} \\lambda_j \\mathbf{u}_{j}^{point} + \\sum_{k \\in \\mathbf{K}} \\mu_k \\mathbf{u}_k^{ray}\n\\end{align}\\]\nwhere \\(\\mathbf{u}_j^{point}\\) and \\(\\mathbf{u}_k^{ray}\\) represent an extreme point and extreme ray, respectively. In addition, \\(\\lambda_j \\geq 0\\) for all \\(j \\in \\mathbf{J}\\) and \\(\\sum_{j \\in \\mathbf{J}}\\lambda_j = 1\\), and \\(\\mu_k \\geq 0\\) for all \\(k \\in \\mathbf{K}\\). It follows that the \\(\\mathbf{DSP}\\) is equivalent to\n\\[\\begin{align}\n\\text{max.} &\\quad (\\mathbf{b} - \\mathbf{B} \\mathbf{y})^{T} (\\sum_{j \\in \\mathbf{J}} \\lambda_j \\mathbf{u}_{j}^{point} + \\sum_{k \\in \\mathbf{K}} \\mu_k \\mathbf{u}_k^{ray}) \\\\\n\\text{s.t.} &\\quad \\sum_{j \\in \\mathbf{J}}\\lambda_j = 1 \\\\\n&\\quad \\lambda_j \\geq 0, \\ \\forall j \\in \\mathbf{J} \\\\\n&\\quad \\mu_k \\geq 0, \\ \\forall k \\in \\mathbf{K}\n\\end{align}\\]\nWe can therefore conclude that\n\nThe \\(\\mathbf{DSP}\\) becomes unbounded if any \\(\\mathbf{u}_k^{ray}\\) exists such that \\((\\mathbf{b} - \\mathbf{B} \\mathbf{y})^{T} \\mathbf{u}_k^{ray} &gt; 0\\). Note that an unbounded \\(\\mathbf{DSP}\\) implies an infeasible \\(\\mathbf{SP}\\) and to prevent this from happening, we have to ensure that \\((\\mathbf{b} - \\mathbf{B} \\mathbf{y})^{T} \\mathbf{u}_k^{ray} \\leq 0\\) for all \\(k \\in \\mathbf{K}\\).\nIf an optimal solution to \\(\\mathbf{DSP}\\) exists, it must occur at one of the extreme points. Let \\(g\\) denote the optimal objective value, it follows that \\((\\mathbf{b} - \\mathbf{B} \\mathbf{y})^{T} \\mathbf{u}_j^{point} \\leq g\\) for all \\(j \\in \\mathbf{J}\\).\n\nBased on this idea, the \\(\\mathbf{DSP}\\) can be reformulated as follows:\n\\[\\begin{align}\n\\text{min.} &\\quad g \\\\\n\\text{s.t.} &\\quad (\\mathbf{b} - \\mathbf{B} \\mathbf{y})^{T} \\mathbf{u}_k^{ray} \\leq 0, \\ \\forall j \\in \\mathbf{J} \\label{bd-feas} \\\\\n&\\quad (\\mathbf{b} - \\mathbf{B} \\mathbf{y})^{T} \\mathbf{u}_j^{point} \\leq g, \\ \\forall k \\in \\mathbf{K} \\label{bd-opt} \\\\\n&\\quad j \\in \\mathbf{J}, k \\in \\mathbf{K}\n\\end{align}\\]\nConstraints \\(\\eqref{bd-feas}\\) are called Benders feasibility cuts, while constraints \\(\\eqref{bd-opt}\\) are called Benders optimality cuts. Now we are ready to define the Benders Master Problem (\\(\\mathbf{BMP}\\)) as follows:\n\\[\\begin{align}\n&(\\mathbf{BMP}) &\\quad \\text{min.} &\\quad \\mathbf{f}^T \\mathbf{y} + g \\\\\n& &\\quad \\text{s.t.} &\\quad (\\mathbf{b} - \\mathbf{B} \\mathbf{y})^{T} \\mathbf{u}_k^{ray} \\leq 0, \\ \\forall j \\in \\mathbf{J} \\\\\n& &\\quad &\\quad (\\mathbf{b} - \\mathbf{B} \\mathbf{y})^{T} \\mathbf{u}_j^{point} \\leq g, \\ \\forall k \\in \\mathbf{K} \\\\\n& &\\quad &\\quad j \\in \\mathbf{J}, k \\in \\mathbf{K}, \\mathbf{y} \\geq 0\n\\end{align}\\]\nTypically \\(J\\) and \\(K\\) are too large to enumerate upfront and we have to work with subsets of them, denoted by \\(J_s\\) and \\(K_s\\), respectively. Hence we have the following Restricted Benders Master Problem (\\(\\mathbf{RBMP}\\)):\n\\[\\begin{align}\n&(\\mathbf{RBMP}) &\\quad \\text{min.} &\\quad \\mathbf{f}^T \\mathbf{y} + g \\\\\n& &\\quad \\text{s.t.} &\\quad (\\mathbf{b} - \\mathbf{B} \\mathbf{y})^{T} \\mathbf{u}_k^{ray} \\leq 0, \\ \\forall j \\in \\mathbf{J}_s \\\\\n& &\\quad &\\quad (\\mathbf{b} - \\mathbf{B} \\mathbf{y})^{T} \\mathbf{u}_j^{point} \\leq g, \\ \\forall k \\in \\mathbf{K}_s \\\\\n& &\\quad &\\quad j \\in \\mathbf{J}, k \\in \\mathbf{K}, \\mathbf{y} \\geq 0\n\\end{align}\\]\n\n\n\n\n\nflowchart LR\n   A[Start] --&gt; B{Is}\n    B --&gt;|Yes| C[OK]\n    C --&gt; D[Rethink]\n    D --&gt; B\n    B ----&gt;|No| E[End]\n\n\nFigure 4.1: Benders decomposition workflow"
  },
  {
    "objectID": "benders-theory.html#a-linear-programming-example",
    "href": "benders-theory.html#a-linear-programming-example",
    "title": "4  Benders Decomposition",
    "section": "4.2 A linear programming example",
    "text": "4.2 A linear programming example\nIn this section, we will first present a small linear programming problem and solve it directly using the Gurobi API in Python - gurobipy. Then we will demonstrate the Benders decomposition approach on this artificial problem. Lastly, we will provide an implementation to solve this problem in gurobipy.\n\n4.2.1 The original problem and its optimal solution\nThe linear program we examine here is devoid of any practical meaning and is solely used to demonstrate the solution process of Benders decomposition. The problem is stated below, in which \\(\\mathbf{x} = (x_1, x_2, x_3)\\) and \\(\\mathbf{y} = (y_1, y_2)\\) are the decision variables. We assume that \\(\\mathbf{y}\\) is the complicating variable.\n\\[\\begin{align*}\n    \\text{min.} &\\quad 8x_1 + 12x_2 +10x_3 + 15y_1 + 18y_2 \\\\\n    \\text{s.t.} &\\quad 2x_1 + 3x_2 + 2x_3 + 4y_1 + 5y_2 = 300 \\\\\n    &\\quad 4x_1 + 2x_2 + 3x_3 + 2y_1 + 3y_2 = 228.75 \\\\\n    &\\quad 1x_1 + 2x_2 + 1x_3 + 1.5y_1 + 2y_2 = 150 \\\\\n    &\\quad 3x_1 + 2x_2 + 2x_3 + 1y_1 + 2y_2 = 180 \\\\\n    &\\quad x_i \\geq 0, \\ \\forall i = 1, \\cdots, 3 \\\\\n    &\\quad y_i \\geq 0, \\ \\forall j = 1, 2\n\\end{align*}\\]\nIn this example, \\(\\mathbf{c}^T = (8, 12, 10)\\), \\(\\mathbf{f}^T = (15, 18)\\) and \\(\\mathbf{b}^T = (300, 228.75, 150, 180)\\). In addition,\n\\[\\begin{equation*}\n\\mathbf{A} =\n\\begin{bmatrix}\n    2 & 3 & 2 \\\\\n    4 & 2 & 3 \\\\\n    1 & 2 & 1 \\\\\n    3 & 2 & 2\n\\end{bmatrix}\n\\qquad\n\\mathbf{B} =\n\\begin{bmatrix}\n    4 & 5 \\\\\n    2 & 3 \\\\\n    1.5 & 2 \\\\\n    1 & 2\n\\end{bmatrix}\n\\end{equation*}\\]\nWe first use Gurobi to identify its optimal solution.\n\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nenv = gp.Env(empty=True)\nenv.setParam('OutputFlag', 0)\nenv.start()\nmodel = gp.Model(env=env, name=\"original_problem\")\n\n# Decision variables\nx1 = model.addVar(vtype=GRB.CONTINUOUS, name='x1')\nx2 = model.addVar(vtype=GRB.CONTINUOUS, name='x2')\nx3 = model.addVar(vtype=GRB.CONTINUOUS, name='x3')\ny1 = model.addVar(vtype=GRB.CONTINUOUS, name='y1')\ny2 = model.addVar(vtype=GRB.CONTINUOUS, name='y2')\n\n# Objective function\nmodel.setObjective(8*x1 + 12*x2 + 10*x3 + 15*y1 + 18*y2, \n                   GRB.MINIMIZE)\n\n# Constraints\nmodel.addConstr(2*x1 + 3*x2 + 2*x3 + 4*y1 + 5*y2 == 300)\nmodel.addConstr(4*x1 + 2*x2 + 3*x3 + 2*y1 + 3*y2 == 220)\n# model.addConstr(1*x1 + 2*x2 + 1*x3 + 1.5*y1 + 2*y2 == 150)\n# model.addConstr(3*x1 + 2*x2 + 2*x3 + 1*y1 + 2*y2 == 180)\n\n# Optimize the model\nmodel.optimize()\n\n# Print the results\nif model.status == GRB.OPTIMAL:\n    print(\"Optimal solution found!\")\n    print(f'x1 = {x1.X:.2f}')\n    print(f'x2 = {x2.X:.2f}')\n    print(f'x3 = {x3.X:.2f}')\n    print(f'y1 = {y1.X:.2f}')\n    print(f'y2 = {y2.X:.2f}')\n    print(f\"Total cost: {model.objVal:.2f}\")\nelse:\n    print(\"No solution found.\")\n\n# Close the Gurobi environment\nmodel.dispose()\nenv.dispose()\n\nThe optimal solution and objective value are as follows.\nOptimal solution found!\nx1 = 14.29\nx2 = 0.00\nx3 = 0.00\ny1 = 0.00\ny2 = 54.29\nTotal cost: 1091.43\n\n\n4.2.2 Benders decomposition\nWe first state the subproblem as follows:\n\\[\\begin{align*}\n    &(\\mathbf{SP}) &\\quad \\text{min.} &\\quad 8x_1 + 12x_2 +10x_3 \\\\\n    &&\\quad \\text{s.t.} &\\quad 2x_1 + 3x_2 + 2x_3 = 300 - 4y_1 - 5y_2 \\\\\n    &&&\\quad 4x_1 + 2x_2 + 3x_3 = 220 - 2y_1 - 3y_2 \\\\\n    &&&\\quad x_i \\geq 0, \\ \\forall i = 1, \\cdots, 3\n\\end{align*}\\]\nWe define two dual variables \\(u_1\\) and \\(u_2\\) to associate with the two constraints in the subproblem. The dual subproblem could then be stated as follows:\n\\[\\begin{align*}\n    &(\\mathbf{DSP}) &\\quad \\text{max.} &\\quad (300 - 4y_1 - 5y_2) u_1 + (220 - 2y_1 + 3y_2) u_2 \\\\\n    &&\\quad \\text{s.t.} &\\quad 2u_1 + 4u_2 \\leq 8\\\\\n    &&&\\quad 3u_1 + 2u_2 \\leq 12 \\\\\n    &&&\\quad 2u_1 + 3u_2 \\leq 10 \\\\\n    &&&\\quad u_1, u_2\\  \\text{unrestricted}\n\\end{align*}\\]\nThe RBMP can be stated as:\n\\[\\begin{align*}\n    &(\\mathbf{RBMP}) &\\quad \\text{min.} &\\quad 15 y_1 + 18 y_2 + g \\\\\n    &&\\quad \\text{s.t.} &\\quad  y_1, y_2 \\geq 0 \\\\\n    &&&\\quad g \\leq 0\n\\end{align*}\\]\n\n\n4.2.3 Implementation\n\nimport gurobipy as gp\nfrom gurobipy import GRB\n\nenv = gp.Env('benders')\n\nSet parameter Username\nSet parameter LogFile to value \"benders\"\n\n\n\nlb = -GRB.INFINITY\nub = GRB.INFINITY\n\n\n# create restricted Benders master problem\nrbmp = gp.Model(env=env, name='RBMP')\n\n# create decision variables\ny1 = rbmp.addVar(vtype=GRB.CONTINUOUS, lb=0, name='y1')\ny2 = rbmp.addVar(vtype=GRB.CONTINUOUS, lb=0, name='y2')\ng = rbmp.addVar(vtype=GRB.CONTINUOUS, lb=0, name='g')\n\n# create objective\nrbmp.setObjective(15*y1 + 18*y2 + g, GRB.MINIMIZE)\n\n\n# create subproblem\nsp = gp.Model(env=env, name='SP')\n\n# create decision variables\nx1 = sp.addVar(vtype=GRB.CONTINUOUS, name='x1')\nx2 = sp.addVar(vtype=GRB.CONTINUOUS, name='x2')\nx3 = sp.addVar(vtype=GRB.CONTINUOUS, name='x3')\n\n# create objective function\nsp.setObjective(8*x1 + 12*x2 + 10*x3, GRB.MINIMIZE)\n\n# create constraints\nsp.addConstr(2*x1 + 3*x2 + 2*x3 == 300, name='c1')\nsp.addConstr(4*x1 + 2*x2 + 3*x3 == 220, name='c2')\n\nsp.update()\n\n\n# create dual subproblem\ndsp = gp.Model(env=env, name='DSP')\n\n# create decision variables\nu1 = dsp.addVar(vtype=GRB.CONTINUOUS, name='u1')\nu2 = dsp.addVar(vtype=GRB.CONTINUOUS, name='u2')\n\n# create objective function\ndsp.setObjective(300*u1 + 220*u2)\n\n# create constraints\ndsp.addConstr(2*u1 + 4*u2 &lt;= 8, name='c1')\ndsp.addConstr(3*u1 + 2*u2 &lt;= 12, name='c2')\ndsp.addConstr(2*u1 + 3*u2 &lt;= 10, name='c3')\n\ndsp.update()\n\nNow we first solve the RBMP:\n\nrbmp.optimize()\n\nif rbmp.status == GRB.OPTIMAL:\n    print(f'optimal solution found!')\n    \n    y1_opt = y1.X\n    y2_opt = y2.X\n    g_opt = g.X\n    \n    print(f'optimal obj: {rbmp.objVal:.2f}')\n    print(f'y1 = {y1_opt:.2f}')\n    print(f'y2 = {y2_opt:.2f}')\n    print(f'g = {g_opt:.2f}')\n    print(f'lb={lb}, ub={ub}')\nelif rbmp.status == GRB.INFEASIBLE:\n    print(f'original problem is infeasible!')\n\nGurobi Optimizer version 10.0.3 build v10.0.3rc0 (mac64[arm])\n\nCPU model: Apple M1\nThread count: 8 physical cores, 8 logical processors, using up to 8 threads\n\nOptimize a model with 0 rows, 3 columns and 0 nonzeros\nModel fingerprint: 0xb00b2c2a\nCoefficient statistics:\n  Matrix range     [0e+00, 0e+00]\n  Objective range  [1e+00, 2e+01]\n  Bounds range     [0e+00, 0e+00]\n  RHS range        [0e+00, 0e+00]\nPresolve removed 0 rows and 3 columns\nPresolve time: 0.00s\nPresolve: All rows and columns removed\nIteration    Objective       Primal Inf.    Dual Inf.      Time\n       0    0.0000000e+00   0.000000e+00   0.000000e+00      0s\n\nSolved in 0 iterations and 0.00 seconds (0.00 work units)\nOptimal objective  0.000000000e+00\noptimal solution found!\noptimal obj: 0.00\ny1 = 0.00\ny2 = 0.00\ng = 0.00\nlb=-1e+100, ub=1e+100\n\n\nNow we have obtained an optimal solution \\((y_1, y_2, g) = (0, 0, 0)\\), we feed the values of \\(y_1\\) and \\(y_2\\) into the Benders subproblem (SP):\n\n# sp_c1 = sp.getConstrByName('c1')\n# sp_c1.rhs = 300 - 4*y1_opt - 5*y2_opt\n# sp_c2 = sp.getConstrByName('c2')\n# sp_c2.rhs = 220 - 2*y1_opt - 3*y2_opt\n\n# sp.update()\n\n# sp.optimize()\n\n# if sp.status == GRB.OPTIMAL:\n#     print('subproblem is optimal!')\n#     x1_opt = x1.X\n#     x2_opt = x2.X\n#     x3_opt = x3.X\n    \n#     print(f'optimal obj: {sp.objVal:.2f}')\n#     print(f'x1 = {x1_opt:.2f}')\n#     print(f'x2 = {x2_opt:.2f}')\n#     print(f'x3 = {x3_opt:.2f}')\n# elif sp.status == GRB.UNBOUNDED:\n#     # the original problem is unbounded\n#     pass\n# elif sp.status == GRB.INFEASIBLE:\n#     # add feasibility cut\n#     pass\n# else:\n#     print(f'unknown error occurred, status: {sp.status}')\n\nGurobi Optimizer version 10.0.3 build v10.0.3rc0 (mac64[arm])\n\nCPU model: Apple M1\nThread count: 8 physical cores, 8 logical processors, using up to 8 threads\n\nOptimize a model with 2 rows, 3 columns and 6 nonzeros\nCoefficient statistics:\n  Matrix range     [2e+00, 4e+00]\n  Objective range  [8e+00, 1e+01]\n  Bounds range     [0e+00, 0e+00]\n  RHS range        [2e+02, 3e+02]\nIteration    Objective       Primal Inf.    Dual Inf.      Time\n       0    1.2000000e+03   0.000000e+00   0.000000e+00      0s\n\nSolved in 0 iterations and 0.01 seconds (0.00 work units)\nOptimal objective  1.200000000e+03\nsubproblem is optimal!\noptimal obj: 1200.00\nx1 = 7.50\nx2 = 95.00\nx3 = 0.00\n\n\n\nimport numpy as np\n\n\n\ndsp.setObjective((300 - 4*y1_opt - 5*y2_opt) * u1 + (220 - 2*y1_opt - 3*y2_opt) * u2, GRB.MAXIMIZE)\n\ndsp.update()\n\ndsp.optimize()\n\nif dsp.status == GRB.OPTIMAL:\n    u1_opt = u1.X\n    u2_opt = u2.X\n    \n    print(f'optimal obj = {dsp.objVal:.2f}')\n    print(f'u1 = {u1_opt:.2f}')\n    print(f'u2 = {u2_opt:.2f}')\n    ub = np.min([ub, 15*y1_opt + 18*y2_opt + dsp.objVal])\n    print(f'lb={lb}, ub={ub}')\n# elif dsp.Status == GRB.UNBOUNDED:\n#     # add feasibility cut\n\nGurobi Optimizer version 10.0.3 build v10.0.3rc0 (mac64[arm])\n\nCPU model: Apple M1\nThread count: 8 physical cores, 8 logical processors, using up to 8 threads\n\nOptimize a model with 3 rows, 2 columns and 6 nonzeros\nCoefficient statistics:\n  Matrix range     [2e+00, 4e+00]\n  Objective range  [2e+02, 3e+02]\n  Bounds range     [0e+00, 0e+00]\n  RHS range        [8e+00, 1e+01]\nIteration    Objective       Primal Inf.    Dual Inf.      Time\n       0    1.2000000e+03   0.000000e+00   0.000000e+00      0s\n\nSolved in 0 iterations and 0.00 seconds (0.00 work units)\nOptimal objective  1.200000000e+03\noptimal obj = 1200.00\nu1 = 4.00\nu2 = 0.00\nlb=-1e+100, ub=1200.0\n\n\n\nnp.min([ub, dsp.objVal])\n\n1200.0\n\n\nSince 1200 &gt; 0, we add optimality cut.\n\nrbmp.addConstr((300 - 4*y1 - 5*y2) * u1_opt + (220 - 2*y1 - 3*y2) * u2_opt &lt;= g, name='c3')\n\nrbmp.update()\n\nrbmp.optimize()\n\nif rbmp.status == GRB.OPTIMAL:\n    print(f'optimal solution found!')\n    \n    y1_opt = y1.X\n    y2_opt = y2.X\n    g_opt = g.X\n    lb = np.max([lb, rbmp.objVal])\n    \n    print(f'optimal obj: {rbmp.objVal:.2f}')\n    print(f'y1 = {y1_opt:.2f}')\n    print(f'y2 = {y2_opt:.2f}')\n    print(f'g = {g_opt:.2f}')\n    print(f'lb={lb}, ub={ub}')\nelif rbmp.status == GRB.INFEASIBLE:\n    print(f'original problem is infeasible!')\n\nGurobi Optimizer version 10.0.3 build v10.0.3rc0 (mac64[arm])\n\nCPU model: Apple M1\nThread count: 8 physical cores, 8 logical processors, using up to 8 threads\n\nOptimize a model with 1 rows, 3 columns and 3 nonzeros\nCoefficient statistics:\n  Matrix range     [1e+00, 2e+01]\n  Objective range  [1e+00, 2e+01]\n  Bounds range     [0e+00, 0e+00]\n  RHS range        [1e+03, 1e+03]\nIteration    Objective       Primal Inf.    Dual Inf.      Time\n       0    0.0000000e+00   1.500000e+02   0.000000e+00      0s\n       1    1.0800000e+03   0.000000e+00   0.000000e+00      0s\n\nSolved in 1 iterations and 0.00 seconds (0.00 work units)\nOptimal objective  1.080000000e+03\noptimal solution found!\noptimal obj: 1080.00\ny1 = 0.00\ny2 = 60.00\ng = 0.00\nlb=1080.0, ub=1200.0\n\n\n\ny1_opt, y2_opt\n\n(0.0, 60.0)\n\n\nNow we solve the subproblem again:\n\ndsp.setObjective((300 - 4*y1_opt - 5*y2_opt) * u1 + (220 - 2*y1_opt - 3*y2_opt) * u2, GRB.MAXIMIZE)\n\ndsp.update()\n\ndsp.optimize()\n\nif dsp.status == GRB.OPTIMAL:\n    u1_opt = u1.X\n    u2_opt = u2.X\n    \n    print(f'optimal obj = {dsp.objVal:.2f}')\n    print(f'u1 = {u1_opt:.2f}')\n    print(f'u2 = {u2_opt:.2f}')\n    ub = np.min([ub, 15*y1_opt + 18*y2_opt + dsp.objVal])\n    print(f'lb={lb}, ub={ub}')\nelif dsp.status == GRB.UNBOUNDED:\n    print(f'dual subproblem is unbounded!')\n\nGurobi Optimizer version 10.0.3 build v10.0.3rc0 (mac64[arm])\n\nCPU model: Apple M1\nThread count: 8 physical cores, 8 logical processors, using up to 8 threads\n\nOptimize a model with 3 rows, 2 columns and 6 nonzeros\nCoefficient statistics:\n  Matrix range     [2e+00, 4e+00]\n  Objective range  [4e+01, 4e+01]\n  Bounds range     [0e+00, 0e+00]\n  RHS range        [8e+00, 1e+01]\nIteration    Objective       Primal Inf.    Dual Inf.      Time\n       0    4.0000000e+31   2.000000e+30   4.000000e+01      0s\n       1    8.0000000e+01   0.000000e+00   0.000000e+00      0s\n\nSolved in 1 iterations and 0.00 seconds (0.00 work units)\nOptimal objective  8.000000000e+01\noptimal obj = 80.00\nu1 = 0.00\nu2 = 2.00\nlb=1080.0, ub=1160.0\n\n\n\nrbmp.addConstr((300 - 4*y1 - 5*y2) * u1_opt + (220 - 2*y1 - 3*y2) * u2_opt &lt;= g, name='c3')\n\nrbmp.update()\n\nrbmp.optimize()\n\nif rbmp.status == GRB.OPTIMAL:\n    print(f'optimal solution found!')\n    \n    y1_opt = y1.X\n    y2_opt = y2.X\n    g_opt = g.X\n    lb = np.max([lb, rbmp.objVal])\n    \n    print(f'optimal obj: {rbmp.objVal:.2f}')\n    print(f'y1 = {y1_opt:.2f}')\n    print(f'y2 = {y2_opt:.2f}')\n    print(f'g = {g_opt:.2f}')\n    print(f'lb={lb}, ub={ub}')\nelif rbmp.status == GRB.INFEASIBLE:\n    print(f'original problem is infeasible!')\n\nGurobi Optimizer version 10.0.3 build v10.0.3rc0 (mac64[arm])\n\nCPU model: Apple M1\nThread count: 8 physical cores, 8 logical processors, using up to 8 threads\n\nOptimize a model with 2 rows, 3 columns and 6 nonzeros\nCoefficient statistics:\n  Matrix range     [1e+00, 2e+01]\n  Objective range  [1e+00, 2e+01]\n  Bounds range     [0e+00, 0e+00]\n  RHS range        [4e+02, 1e+03]\nIteration    Objective       Primal Inf.    Dual Inf.      Time\n       0    1.0800000e+03   4.000000e+01   0.000000e+00      0s\n       1    1.0914286e+03   0.000000e+00   0.000000e+00      0s\n\nSolved in 1 iterations and 0.01 seconds (0.00 work units)\nOptimal objective  1.091428571e+03\noptimal solution found!\noptimal obj: 1091.43\ny1 = 0.00\ny2 = 54.29\ng = 114.29\nlb=1091.4285714285713, ub=1160.0\n\n\n\ndsp.setObjective((300 - 4*y1_opt - 5*y2_opt) * u1 + (220 - 2*y1_opt - 3*y2_opt) * u2, GRB.MAXIMIZE)\n\ndsp.update()\n\ndsp.optimize()\n\nif dsp.status == GRB.OPTIMAL:\n    u1_opt = u1.X\n    u2_opt = u2.X\n    \n    print(f'optimal obj = {dsp.objVal:.2f}')\n    print(f'u1 = {u1_opt:.2f}')\n    print(f'u2 = {u2_opt:.2f}')\n    ub = np.min([ub, 15*y1_opt + 18*y2_opt + dsp.objVal])\n    print(f'lb={lb}, ub={ub}')\nelif dsp.status == GRB.UNBOUNDED:\n    print(f'dual subproblem is unbounded!')\n\nGurobi Optimizer version 10.0.3 build v10.0.3rc0 (mac64[arm])\n\nCPU model: Apple M1\nThread count: 8 physical cores, 8 logical processors, using up to 8 threads\n\nOptimize a model with 3 rows, 2 columns and 6 nonzeros\nCoefficient statistics:\n  Matrix range     [2e+00, 4e+00]\n  Objective range  [3e+01, 6e+01]\n  Bounds range     [0e+00, 0e+00]\n  RHS range        [8e+00, 1e+01]\nIteration    Objective       Primal Inf.    Dual Inf.      Time\n       0    1.1428571e+02   0.000000e+00   0.000000e+00      0s\n\nSolved in 0 iterations and 0.00 seconds (0.00 work units)\nOptimal objective  1.142857143e+02\noptimal obj = 114.29\nu1 = 0.00\nu2 = 2.00\nlb=1091.4285714285713, ub=1091.4285714285713\n\n\n\ny1_opt, y2_opt\n\n(0.0, 54.285714285714285)"
  }
]