[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Hands-on Large Scale Optimization in Python",
    "section": "",
    "text": "Preface"
  },
  {
    "objectID": "preface.html#install-homebrew",
    "href": "preface.html#install-homebrew",
    "title": "1  Environment Setup",
    "section": "1.1 Install Homebrew",
    "text": "1.1 Install Homebrew\nThe first tool we need is Homebrew, ‘the Missing Package Manager for macOS (or Linux)’, and it can be accessed at https://brew.sh/. To install Homebrew, just copy the command below and run it in the Terminal.\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\nWe can then use the brew --version command to check the installed version. On my system, it shows the info below.\n ~/ brew --version\nHomebrew 3.6.20\nHomebrew/homebrew-core (git revision 5f1582e4d55; last commit 2023-02-05)\nHomebrew/homebrew-cask (git revision fa3b8a669d; last commit 2023-02-05)"
  },
  {
    "objectID": "preface.html#install-anaconda",
    "href": "preface.html#install-anaconda",
    "title": "1  Environment Setup",
    "section": "1.2 Install Anaconda",
    "text": "1.2 Install Anaconda\nSince there are several Python versions available for our use and we may end up having multiple Python versions installed on our machine, it is important to use a consistent environment to work on our project in. Anaconda is a package and environment manager for Python and it provides easy-to-use tools to facilitate our data science needs. To install Anaconda, run the below command in the Terminal.\n ~/ brew install anaconda\nAfter the installation is done, we can use conda --version to verify whether it is available on our machine or not.\n ~/ conda --version\nconda 23.1.0"
  },
  {
    "objectID": "preface.html#create-a-conda-environment",
    "href": "preface.html#create-a-conda-environment",
    "title": "1  Environment Setup",
    "section": "1.3 Create a Conda Environment",
    "text": "1.3 Create a Conda Environment\nNow we will create a Conda environment named ‘ortools’. Execute the below command in the Terminal, which effectively creates the required environment with Python version 3.10.\n ~/ conda create -n ortools python=3.10\nRetrieving notices: ...working... done\nCollecting package metadata (current_repodata.json): done\nSolving environment: done\n\n## Package Plan ##\n\n  environment location: /opt/homebrew/anaconda3/envs/test\n\n  added / updated specs:\n    - python=3.10\n\n\nThe following packages will be downloaded:\n\n    package                    |            build\n    ---------------------------|-----------------\n    setuptools-67.4.0          |     pyhd8ed1ab_0         567 KB  conda-forge\n    ------------------------------------------------------------\n                                           Total:         567 KB\n\nThe following NEW packages will be INSTALLED:\n\n  bzip2              conda-forge/osx-arm64::bzip2-1.0.8-h3422bc3_4\n  ca-certificates    conda-forge/osx-arm64::ca-certificates-2022.12.7-h4653dfc_0\n  libffi             conda-forge/osx-arm64::libffi-3.4.2-h3422bc3_5\n  libsqlite          conda-forge/osx-arm64::libsqlite-3.40.0-h76d750c_0\n  libzlib            conda-forge/osx-arm64::libzlib-1.2.13-h03a7124_4\n  ncurses            conda-forge/osx-arm64::ncurses-6.3-h07bb92c_1\n  openssl            conda-forge/osx-arm64::openssl-3.0.8-h03a7124_0\n  pip                conda-forge/noarch::pip-23.0.1-pyhd8ed1ab_0\n  python             conda-forge/osx-arm64::python-3.10.9-h3ba56d0_0_cpython\n  readline           conda-forge/osx-arm64::readline-8.1.2-h46ed386_0\n  setuptools         conda-forge/noarch::setuptools-67.4.0-pyhd8ed1ab_0\n  tk                 conda-forge/osx-arm64::tk-8.6.12-he1e0b03_0\n  tzdata             conda-forge/noarch::tzdata-2022g-h191b570_0\n  wheel              conda-forge/noarch::wheel-0.38.4-pyhd8ed1ab_0\n  xz                 conda-forge/osx-arm64::xz-5.2.6-h57fd34a_0\n\n\nProceed ([y]/n)?\nType ‘y’ to proceed and Conda will create the environment for us. We can use cnoda env list to show all the created environments on our machine:\n ~/ conda env list\n# conda environments:\n#\nbase                     /opt/homebrew/anaconda3\nortools                   /opt/homebrew/anaconda3/envs/ortools\nNote that we need to manually activate an environemnt in order to use it: conda activate ortools. On my machine, the activated environment ortools will appear in the beginning of my prompt.\n ~/ conda activate ortools\n(ortools)  ~/"
  },
  {
    "objectID": "preface.html#install-google-or-tools",
    "href": "preface.html#install-google-or-tools",
    "title": "1  Environment Setup",
    "section": "1.4 Install Google OR-Tools",
    "text": "1.4 Install Google OR-Tools\nAs of this writing, the latest version of Google OR-Tools is 9.5.2237, and we can install it in our newly created environment using the command pip install ortools==9.5.2237. We can use conda list to verify whether it is available in our environment.\n(ortools)  ~/ conda list\n# packages in environment at /opt/homebrew/anaconda3/envs/ortools:\n#\n# Name                    Version                   Build  Channel\nabsl-py                   1.4.0                    pypi_0    pypi\nbzip2                     1.0.8                h3422bc3_4    conda-forge\nca-certificates           2022.12.7            h4653dfc_0    conda-forge\nlibffi                    3.4.2                h3422bc3_5    conda-forge\nlibsqlite                 3.40.0               h76d750c_0    conda-forge\nlibzlib                   1.2.13               h03a7124_4    conda-forge\nncurses                   6.3                  h07bb92c_1    conda-forge\nnumpy                     1.24.2                   pypi_0    pypi\nopenssl                   3.0.8                h03a7124_0    conda-forge\nortools                   9.5.2237                 pypi_0    pypi\npip                       23.0.1             pyhd8ed1ab_0    conda-forge\nprotobuf                  4.22.0                   pypi_0    pypi\npython                    3.10.9          h3ba56d0_0_cpython    conda-forge\nreadline                  8.1.2                h46ed386_0    conda-forge\nsetuptools                67.4.0             pyhd8ed1ab_0    conda-forge\ntk                        8.6.12               he1e0b03_0    conda-forge\ntzdata                    2022g                h191b570_0    conda-forge\nwheel                     0.38.4             pyhd8ed1ab_0    conda-forge\nxz                        5.2.6                h57fd34a_0    conda-forge\nNow we have Python and Google OR-Tools ready, we can start our next journey."
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "2  Introduction",
    "section": "",
    "text": "This is a book created from markdown and executable code.\nSee Knuth (1984) for additional discussion of literate programming.\n\n\n\n\nKnuth, Donald E. 1984. “Literate Programming.” Comput. J. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97."
  },
  {
    "objectID": "env-setup.html#install-homebrew",
    "href": "env-setup.html#install-homebrew",
    "title": "3  Environment Setup",
    "section": "3.1 Install Homebrew",
    "text": "3.1 Install Homebrew\nThe first tool we need is Homebrew, ‘the Missing Package Manager for macOS (or Linux)’, and it can be accessed at https://brew.sh/. To install Homebrew, just copy the command below and run it in the Terminal.\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\nWe can then use the brew --version command to check the installed version. On my system, it shows the info below.\n ~/ brew --version\nHomebrew 3.6.20\nHomebrew/homebrew-core (git revision 5f1582e4d55; last commit 2023-02-05)\nHomebrew/homebrew-cask (git revision fa3b8a669d; last commit 2023-02-05)"
  },
  {
    "objectID": "env-setup.html#install-anaconda",
    "href": "env-setup.html#install-anaconda",
    "title": "3  Environment Setup",
    "section": "3.2 Install Anaconda",
    "text": "3.2 Install Anaconda\nSince there are several Python versions available for our use and we may end up having multiple Python versions installed on our machine, it is important to use a consistent environment to work on our project in. Anaconda is a package and environment manager for Python and it provides easy-to-use tools to facilitate our data science needs. To install Anaconda, run the below command in the Terminal.\n ~/ brew install anaconda\nAfter the installation is done, we can use conda --version to verify whether it is available on our machine or not.\n ~/ conda --version\nconda 23.1.0"
  },
  {
    "objectID": "env-setup.html#create-a-conda-environment",
    "href": "env-setup.html#create-a-conda-environment",
    "title": "3  Environment Setup",
    "section": "3.3 Create a Conda Environment",
    "text": "3.3 Create a Conda Environment\nNow we will create a Conda environment named ‘ortools’. Execute the below command in the Terminal, which effectively creates the required environment with Python version 3.10.\n ~/ conda create -n ortools python=3.10\nRetrieving notices: ...working... done\nCollecting package metadata (current_repodata.json): done\nSolving environment: done\n\n## Package Plan ##\n\n  environment location: /opt/homebrew/anaconda3/envs/test\n\n  added / updated specs:\n    - python=3.10\n\n\nThe following packages will be downloaded:\n\n    package                    |            build\n    ---------------------------|-----------------\n    setuptools-67.4.0          |     pyhd8ed1ab_0         567 KB  conda-forge\n    ------------------------------------------------------------\n                                           Total:         567 KB\n\nThe following NEW packages will be INSTALLED:\n\n  bzip2              conda-forge/osx-arm64::bzip2-1.0.8-h3422bc3_4\n  ca-certificates    conda-forge/osx-arm64::ca-certificates-2022.12.7-h4653dfc_0\n  libffi             conda-forge/osx-arm64::libffi-3.4.2-h3422bc3_5\n  libsqlite          conda-forge/osx-arm64::libsqlite-3.40.0-h76d750c_0\n  libzlib            conda-forge/osx-arm64::libzlib-1.2.13-h03a7124_4\n  ncurses            conda-forge/osx-arm64::ncurses-6.3-h07bb92c_1\n  openssl            conda-forge/osx-arm64::openssl-3.0.8-h03a7124_0\n  pip                conda-forge/noarch::pip-23.0.1-pyhd8ed1ab_0\n  python             conda-forge/osx-arm64::python-3.10.9-h3ba56d0_0_cpython\n  readline           conda-forge/osx-arm64::readline-8.1.2-h46ed386_0\n  setuptools         conda-forge/noarch::setuptools-67.4.0-pyhd8ed1ab_0\n  tk                 conda-forge/osx-arm64::tk-8.6.12-he1e0b03_0\n  tzdata             conda-forge/noarch::tzdata-2022g-h191b570_0\n  wheel              conda-forge/noarch::wheel-0.38.4-pyhd8ed1ab_0\n  xz                 conda-forge/osx-arm64::xz-5.2.6-h57fd34a_0\n\n\nProceed ([y]/n)?\nType ‘y’ to proceed and Conda will create the environment for us. We can use cnoda env list to show all the created environments on our machine:\n ~/ conda env list\n# conda environments:\n#\nbase                     /opt/homebrew/anaconda3\nortools                   /opt/homebrew/anaconda3/envs/ortools\nNote that we need to manually activate an environemnt in order to use it: conda activate ortools. On my machine, the activated environment ortools will appear in the beginning of my prompt.\n ~/ conda activate ortools\n(ortools)  ~/"
  },
  {
    "objectID": "env-setup.html#install-google-or-tools",
    "href": "env-setup.html#install-google-or-tools",
    "title": "3  Environment Setup",
    "section": "3.4 Install Google OR-Tools",
    "text": "3.4 Install Google OR-Tools\nAs of this writing, the latest version of Google OR-Tools is 9.5.2237, and we can install it in our newly created environment using the command pip install ortools==9.5.2237. We can use conda list to verify whether it is available in our environment.\n(ortools)  ~/ conda list\n# packages in environment at /opt/homebrew/anaconda3/envs/ortools:\n#\n# Name                    Version                   Build  Channel\nabsl-py                   1.4.0                    pypi_0    pypi\nbzip2                     1.0.8                h3422bc3_4    conda-forge\nca-certificates           2022.12.7            h4653dfc_0    conda-forge\nlibffi                    3.4.2                h3422bc3_5    conda-forge\nlibsqlite                 3.40.0               h76d750c_0    conda-forge\nlibzlib                   1.2.13               h03a7124_4    conda-forge\nncurses                   6.3                  h07bb92c_1    conda-forge\nnumpy                     1.24.2                   pypi_0    pypi\nopenssl                   3.0.8                h03a7124_0    conda-forge\nortools                   9.5.2237                 pypi_0    pypi\npip                       23.0.1             pyhd8ed1ab_0    conda-forge\nprotobuf                  4.22.0                   pypi_0    pypi\npython                    3.10.9          h3ba56d0_0_cpython    conda-forge\nreadline                  8.1.2                h46ed386_0    conda-forge\nsetuptools                67.4.0             pyhd8ed1ab_0    conda-forge\ntk                        8.6.12               he1e0b03_0    conda-forge\ntzdata                    2022g                h191b570_0    conda-forge\nwheel                     0.38.4             pyhd8ed1ab_0    conda-forge\nxz                        5.2.6                h57fd34a_0    conda-forge\nNow we have Python and Google OR-Tools ready, we can start our next journey."
  },
  {
    "objectID": "benders-theory.html#the-decomposition-logic",
    "href": "benders-theory.html#the-decomposition-logic",
    "title": "4  Benders Decomposition",
    "section": "4.1 The Decomposition Logic",
    "text": "4.1 The Decomposition Logic\nTo explain the reasoning of Benders decomposition, let us look at the standard form of linear programming problems that involve two vector variables, \\(\\mathbf{x}\\) and \\(\\mathbf{y}\\). Let \\(p\\) and \\(q\\) indicate the dimensions of \\(\\mathbf{x}\\) and \\(\\mathbf{y}\\), respectively. Below is the original problem \\(\\mathbf{P}\\) we intend to solve.\n\\[\\begin{align}\n&(\\mathbf{P}) &\\quad \\text{min.} &\\quad \\mathbf{c}^T \\mathbf{x} + \\mathbf{f}^T \\mathbf{y} \\\\\n& &\\quad \\text{s.t.} &\\quad \\mathbf{A} \\mathbf{x} + \\mathbf{B} \\mathbf{y} = \\mathbf{b} \\\\\n& &\\quad &\\quad \\mathbf{x} \\geq 0, \\mathbf{y} \\geq 0\n\\end{align}\\]\nIn this formulation, \\(\\mathbf{c}\\) and \\(\\mathbf{f}\\) in the objective function represent the cost coefficients associated with decision variables \\(\\mathbf{x}\\) and \\(\\mathbf{y}\\), respectively. Both of them are column vectors of corresponding dimensions. In the constraints, matrix \\(\\mathbf{A}\\) is of dimension \\(m \\times p\\), and matrix \\(\\mathbf{B}\\) is of dimension \\(m \\times q\\). \\(\\mathbf{b}\\) is a column vector of dimension \\(m\\).\nSuppose the variable \\(\\mathbf{y}\\) is a complicating variable in the sense that the resulting problem is substantially easier to solve if the value of \\(\\mathbf{y}\\) is fixed. In this case, we could rewrite problem \\(\\mathbf{P}\\) as the following form:\n\\[\\begin{align}\n\\text{min.} &\\quad \\mathbf{f}^T \\mathbf{y} + g(\\mathbf{y}) \\\\\n\\text{s.t.} &\\quad \\mathbf{y} \\geq 0\n\\end{align}\\]\nwhere \\(g(\\mathbf{y})\\) is a function of \\(\\mathbf{y}\\) and is defined as the subproblem \\(\\mathbf{SP}\\) of the form below:\n\\[\\begin{align}\n&(\\mathbf{SP}) &\\quad \\text{min.} &\\quad \\mathbf{c}^T \\mathbf{x} \\\\\n& &\\quad \\text{s.t.} &\\quad \\mathbf{A} \\mathbf{x}  = \\mathbf{b} - \\mathbf{B} \\mathbf{y} \\label{bd-cons1} \\\\\n& &\\quad &\\quad \\mathbf{x} \\geq 0\n\\end{align}\\]\nNote that the \\(\\mathbf{y}\\) in constraint \\(\\eqref{bd-cons1}\\) takes on some known values when the problem is solved and the only decision variable in the above formulation is \\(\\mathbf{x}\\). The dual problem of \\(\\mathbf{SP}\\), \\(\\mathbf{DSP}\\), is given below.\n\\[\\begin{align}\n&(\\mathbf{DSP}) &\\quad \\text{max.} &\\quad (\\mathbf{b} - \\mathbf{B} \\mathbf{y})^{T} \\mathbf{u} \\\\\n& &\\quad \\text{s.t.} &\\quad \\mathbf{A}^T \\mathbf{u} \\leq \\mathbf{c} \\label{bd-cons2} \\\\\n& &\\quad &\\quad \\mathbf{u}\\  \\text{unrestricted}\n\\end{align}\\]\nA key characteristic of the above \\(\\mathbf{DSP}\\) is that its solution space does not depend on the value of \\(\\mathbf{y}\\), which only affects the objective function. According to the Minkowski’s representation theorem, any \\(\\bar{\\mathbf{u}}\\) satisfying the constraints \\(\\eqref{bd-cons2}\\) can be expressed as\n\\[\\begin{align}\n\\bar{\\mathbf{u}} = \\sum_{j \\in \\mathbf{J}} \\lambda_j \\mathbf{u}_{j}^{point} + \\sum_{k \\in \\mathbf{K}} \\mu_k \\mathbf{u}_k^{ray}\n\\end{align}\\]\nwhere \\(\\mathbf{u}_j^{point}\\) and \\(\\mathbf{u}_k^{ray}\\) represent an extreme point and extreme ray, respectively. In addition, \\(\\lambda_j \\geq 0\\) for all \\(j \\in \\mathbf{J}\\) and \\(\\sum_{j \\in \\mathbf{J}}\\lambda_j = 1\\), and \\(\\mu_k \\geq 0\\) for all \\(k \\in \\mathbf{K}\\). It follows that the \\(\\mathbf{DSP}\\) is equivalent to\n\\[\\begin{align}\n\\text{max.} &\\quad (\\mathbf{b} - \\mathbf{B} \\mathbf{y})^{T} (\\sum_{j \\in \\mathbf{J}} \\lambda_j \\mathbf{u}_{j}^{point} + \\sum_{k \\in \\mathbf{K}} \\mu_k \\mathbf{u}_k^{ray}) \\\\\n\\text{s.t.} &\\quad \\sum_{j \\in \\mathbf{J}}\\lambda_j = 1 \\\\\n&\\quad \\lambda_j \\geq 0, \\ \\forall j \\in \\mathbf{J} \\\\\n&\\quad \\mu_k \\geq 0, \\ \\forall k \\in \\mathbf{K}\n\\end{align}\\]\nWe can therefore conclude that\n\nThe \\(\\mathbf{DSP}\\) becomes unbounded if any \\(\\mathbf{u}_k^{ray}\\) exists such that \\((\\mathbf{b} - \\mathbf{B} \\mathbf{y})^{T} \\mathbf{u}_k^{ray} &gt; 0\\). Note that an unbounded \\(\\mathbf{DSP}\\) implies an infeasible \\(\\mathbf{SP}\\) and to prevent this from happening, we have to ensure that \\((\\mathbf{b} - \\mathbf{B} \\mathbf{y})^{T} \\mathbf{u}_k^{ray} \\leq 0\\) for all \\(k \\in \\mathbf{K}\\).\nIf an optimal solution to \\(\\mathbf{DSP}\\) exists, it must occur at one of the extreme points. Let \\(g\\) denote the optimal objective value, it follows that \\((\\mathbf{b} - \\mathbf{B} \\mathbf{y})^{T} \\mathbf{u}_j^{point} \\leq g\\) for all \\(j \\in \\mathbf{J}\\).\n\nBased on this idea, the \\(\\mathbf{DSP}\\) can be reformulated as follows:\n\\[\\begin{align}\n\\text{min.} &\\quad g \\\\\n\\text{s.t.} &\\quad (\\mathbf{b} - \\mathbf{B} \\mathbf{y})^{T} \\mathbf{u}_k^{ray} \\leq 0, \\ \\forall j \\in \\mathbf{J} \\label{bd-feas} \\\\\n&\\quad (\\mathbf{b} - \\mathbf{B} \\mathbf{y})^{T} \\mathbf{u}_j^{point} \\leq g, \\ \\forall k \\in \\mathbf{K} \\label{bd-opt} \\\\\n&\\quad j \\in \\mathbf{J}, k \\in \\mathbf{K}\n\\end{align}\\]\nConstraints \\(\\eqref{bd-feas}\\) are called Benders feasibility cuts, while constraints \\(\\eqref{bd-opt}\\) are called Benders optimality cuts. Now we are ready to define the Benders Master Problem (\\(\\mathbf{BMP}\\)) as follows:\n\\[\\begin{align}\n&(\\mathbf{BMP}) &\\quad \\text{min.} &\\quad \\mathbf{f}^T \\mathbf{y} + g \\\\\n& &\\quad \\text{s.t.} &\\quad (\\mathbf{b} - \\mathbf{B} \\mathbf{y})^{T} \\mathbf{u}_k^{ray} \\leq 0, \\ \\forall j \\in \\mathbf{J} \\\\\n& &\\quad &\\quad (\\mathbf{b} - \\mathbf{B} \\mathbf{y})^{T} \\mathbf{u}_j^{point} \\leq g, \\ \\forall k \\in \\mathbf{K} \\\\\n& &\\quad &\\quad j \\in \\mathbf{J}, k \\in \\mathbf{K}, \\mathbf{y} \\geq 0\n\\end{align}\\]\nTypically \\(J\\) and \\(K\\) are too large to enumerate upfront and we have to work with subsets of them, denoted by \\(J_s\\) and \\(K_s\\), respectively. Hence we have the following Restricted Benders Master Problem (\\(\\mathbf{RBMP}\\)):\n\\[\\begin{align}\n&(\\mathbf{RBMP}) &\\quad \\text{min.} &\\quad \\mathbf{f}^T \\mathbf{y} + g \\\\\n& &\\quad \\text{s.t.} &\\quad (\\mathbf{b} - \\mathbf{B} \\mathbf{y})^{T} \\mathbf{u}_k^{ray} \\leq 0, \\ \\forall j \\in \\mathbf{J}_s \\\\\n& &\\quad &\\quad (\\mathbf{b} - \\mathbf{B} \\mathbf{y})^{T} \\mathbf{u}_j^{point} \\leq g, \\ \\forall k \\in \\mathbf{K}_s \\\\\n& &\\quad &\\quad j \\in \\mathbf{J}, k \\in \\mathbf{K}, \\mathbf{y} \\geq 0\n\\end{align}\\]\n\n\n\n\n\nflowchart LR\n   A[Start] --&gt; B{Is}\n    B --&gt;|Yes| C[OK]\n    C --&gt; D[Rethink]\n    D --&gt; B\n    B ----&gt;|No| E[End]\n\n\nFigure 4.1: Benders decomposition workflow"
  },
  {
    "objectID": "benders-theory.html#a-linear-programming-example",
    "href": "benders-theory.html#a-linear-programming-example",
    "title": "4  Benders Decomposition",
    "section": "4.2 A linear programming example",
    "text": "4.2 A linear programming example\nIn this section, we will first present a small linear programming problem and solve it directly using the Gurobi API in Python - gurobipy. Then we will demonstrate the Benders decomposition approach on this artificial problem. Lastly, we will provide an implementation to solve this problem in gurobipy.\n\n4.2.1 The original problem and its optimal solution\nThe linear program we examine here is devoid of any practical meaning and is solely used to demonstrate the solution process of Benders decomposition. The problem is stated below, in which \\(\\mathbf{x} = (x_1, x_2, x_3)\\) and \\(\\mathbf{y} = (y_1, y_2)\\) are the decision variables. We assume that \\(\\mathbf{y}\\) is the complicating variable.\n\\[\\begin{align*}\n    \\text{min.} &\\quad 8x_1 + 12x_2 +10x_3 + 15y_1 + 18y_2 \\\\\n    \\text{s.t.} &\\quad 2x_1 + 3x_2 + 2x_3 + 4y_1 + 5y_2 = 300 \\\\\n    &\\quad 4x_1 + 2x_2 + 3x_3 + 2y_1 + 3y_2 = 228.75 \\\\\n    &\\quad 1x_1 + 2x_2 + 1x_3 + 1.5y_1 + 2y_2 = 150 \\\\\n    &\\quad 3x_1 + 2x_2 + 2x_3 + 1y_1 + 2y_2 = 180 \\\\\n    &\\quad x_i \\geq 0, \\ \\forall i = 1, \\cdots, 3 \\\\\n    &\\quad y_i \\geq 0, \\ \\forall j = 1, 2\n\\end{align*}\\]\nIn this example, \\(\\mathbf{c}^T = (8, 12, 10)\\), \\(\\mathbf{f}^T = (15, 18)\\) and \\(\\mathbf{b}^T = (300, 228.75, 150, 180)\\). In addition,\n\\[\\begin{equation*}\n\\mathbf{A} =\n\\begin{bmatrix}\n    2 & 3 & 2 \\\\\n    4 & 2 & 3 \\\\\n    1 & 2 & 1 \\\\\n    3 & 2 & 2\n\\end{bmatrix}\n\\qquad\n\\mathbf{B} =\n\\begin{bmatrix}\n    4 & 5 \\\\\n    2 & 3 \\\\\n    1.5 & 2 \\\\\n    1 & 2\n\\end{bmatrix}\n\\end{equation*}\\]\nWe first use Gurobi to identify its optimal solution.\n\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create a new model\nenv = gp.Env(empty=True)\nenv.setParam('OutputFlag', 0)\nenv.start()\nmodel = gp.Model(env=env, name=\"original_problem\")\n\n# Decision variables\nx1 = model.addVar(vtype=GRB.CONTINUOUS, name='x1')\nx2 = model.addVar(vtype=GRB.CONTINUOUS, name='x2')\nx3 = model.addVar(vtype=GRB.CONTINUOUS, name='x3')\ny1 = model.addVar(vtype=GRB.CONTINUOUS, name='y1')\ny2 = model.addVar(vtype=GRB.CONTINUOUS, name='y2')\n\n# Objective function\nmodel.setObjective(8*x1 + 12*x2 + 10*x3 + 15*y1 + 18*y2, \n                   GRB.MINIMIZE)\n\n# Constraints\nmodel.addConstr(2*x1 + 3*x2 + 2*x3 + 4*y1 + 5*y2 == 300)\nmodel.addConstr(4*x1 + 2*x2 + 3*x3 + 2*y1 + 3*y2 == 220)\n# model.addConstr(1*x1 + 2*x2 + 1*x3 + 1.5*y1 + 2*y2 == 150)\n# model.addConstr(3*x1 + 2*x2 + 2*x3 + 1*y1 + 2*y2 == 180)\n\n# Optimize the model\nmodel.optimize()\n\n# Print the results\nif model.status == GRB.OPTIMAL:\n    print(\"Optimal solution found!\")\n    print(f'x1 = {x1.X:.2f}')\n    print(f'x2 = {x2.X:.2f}')\n    print(f'x3 = {x3.X:.2f}')\n    print(f'y1 = {y1.X:.2f}')\n    print(f'y2 = {y2.X:.2f}')\n    print(f\"Total cost: {model.objVal:.2f}\")\nelse:\n    print(\"No solution found.\")\n\n# Close the Gurobi environment\nmodel.dispose()\nenv.dispose()\n\nThe optimal solution and objective value are as follows.\nOptimal solution found!\nx1 = 14.29\nx2 = 0.00\nx3 = 0.00\ny1 = 0.00\ny2 = 54.29\nTotal cost: 1091.43\n\n\n4.2.2 Benders decomposition\nWe first state the subproblem as follows:\n\\[\\begin{align*}\n    &(\\mathbf{SP}) &\\quad \\text{min.} &\\quad 8x_1 + 12x_2 +10x_3 \\\\\n    &&\\quad \\text{s.t.} &\\quad 2x_1 + 3x_2 + 2x_3 = 300 - 4y_1 - 5y_2 \\\\\n    &&&\\quad 4x_1 + 2x_2 + 3x_3 = 220 - 2y_1 - 3y_2 \\\\\n    &&&\\quad x_i \\geq 0, \\ \\forall i = 1, \\cdots, 3\n\\end{align*}\\]\nWe define two dual variables \\(u_1\\) and \\(u_2\\) to associate with the two constraints in the subproblem. The dual subproblem could then be stated as follows:\n\\[\\begin{align*}\n    &(\\mathbf{DSP}) &\\quad \\text{max.} &\\quad (300 - 4y_1 - 5y_2) u_1 + (220 - 2y_1 + 3y_2) u_2 \\\\\n    &&\\quad \\text{s.t.} &\\quad 2u_1 + 4u_2 \\leq 8\\\\\n    &&&\\quad 3u_1 + 2u_2 \\leq 12 \\\\\n    &&&\\quad 2u_1 + 3u_2 \\leq 10 \\\\\n    &&&\\quad u_1, u_2\\  \\text{unrestricted}\n\\end{align*}\\]\nThe RBMP can be stated as:\n\\[\\begin{align*}\n    &(\\mathbf{RBMP}) &\\quad \\text{min.} &\\quad 15 y_1 + 18 y_2 + g \\\\\n    &&\\quad \\text{s.t.} &\\quad  y_1, y_2 \\geq 0 \\\\\n    &&&\\quad g \\leq 0\n\\end{align*}\\]\n\n\n4.2.3 Solving the problem step by step\nIn this section, we will solve the linear program step by step using Gurobi. To this end, we first import the necessary libraries and create an environment env.\n\n#｜ output: false\nimport numpy as np\nimport gurobipy as gp\nfrom gurobipy import GRB\n\nenv = gp.Env('benders')\nenv.setParam('OutputFlag', 0)\n\nNext, we initialize several algorithm parameters, specifically, we use lb and ub to represent the lower and upper bounds of the solution. The eps is defined as a small number to decide whether the searching process should stop.\nThe remaining codes aim to create the restricted master Benders problem indicated by rbmp. Note that it only has the \\(y\\) and \\(g\\) variables and the objective function, there is no constraint added to the model yet.\n\n# parameters\nlb = -GRB.INFINITY\nub = GRB.INFINITY\neps = 1.0e-5\n\n# create restricted Benders master problem\nrbmp = gp.Model(env=env, name='RBMP')\n\n# create decision variables\ny1 = rbmp.addVar(vtype=GRB.CONTINUOUS, lb=0, name='y1')\ny2 = rbmp.addVar(vtype=GRB.CONTINUOUS, lb=0, name='y2')\ng = rbmp.addVar(vtype=GRB.CONTINUOUS, lb=0, name='g')\n\n# create objective\nrbmp.setObjective(15*y1 + 18*y2 + g, GRB.MINIMIZE)\n\nWe then define the model in Gurobi to solve the dual subproblem, represented by dsp. It consists of two decision variables u1 and u2. The constraints are created in lines 12 - 14.\n\n# create dual subproblem\ndsp = gp.Model(env=env, name='DSP')\n\n# create decision variables\nu1 = dsp.addVar(vtype=GRB.CONTINUOUS, name='u1')\nu2 = dsp.addVar(vtype=GRB.CONTINUOUS, name='u2')\n\n# create objective function\ndsp.setObjective(300*u1 + 220*u2)\n\n# create constraints\ndsp.addConstr(2*u1 + 4*u2 &lt;= 8, name='c1')\ndsp.addConstr(3*u1 + 2*u2 &lt;= 12, name='c2')\ndsp.addConstr(2*u1 + 3*u2 &lt;= 10, name='c3')\n\ndsp.update()\n\nIn the very first iteration, we solve the RBMP, as shown in the following code snippet.\n\nrbmp.optimize()\n\nif rbmp.status == GRB.OPTIMAL:\n    print(f'optimal solution found!')\n    \n    y1_opt = y1.X\n    y2_opt = y2.X\n    g_opt = g.X\n    lb = np.max([lb, rbmp.objVal])\n    \n    print(f'optimal obj: {rbmp.objVal:.2f}')\n    print(f'y1 = {y1_opt:.2f}')\n    print(f'y2 = {y2_opt:.2f}')\n    print(f'g = {g_opt:.2f}')\n    print(f'lb={lb}, ub={ub}')\nelif rbmp.status == GRB.INFEASIBLE:\n    print(f'original problem is infeasible!')\n\noptimal solution found!\noptimal obj: 0.00\ny1 = 0.00\ny2 = 0.00\ng = 0.00\nlb=0.0, ub=1200.0\n\n\nNow we have obtained an optimal solution \\((\\bar{y_1}, \\bar{y_2}, \\bar{g}) = (0, 0, 0)\\), which also provides a new lower bound to our problem. We now feed the values of \\(\\bar{y_1}\\) and \\(\\bar{y_2}\\) into the Benders subproblem (SP):\n\n\ndsp.setObjective((300-4*y1_opt-5*y2_opt)*u1 + \n                 (220-2*y1_opt-3*y2_opt)*u2, \n                 GRB.MAXIMIZE)\ndsp.update()\ndsp.optimize()\n\nif dsp.status == GRB.OPTIMAL:\n    u1_opt = u1.X\n    u2_opt = u2.X\n    \n    print(f'optimal obj = {dsp.objVal:.2f}')\n    print(f'u1 = {u1_opt:.2f}')\n    print(f'u2 = {u2_opt:.2f}')\n    ub = np.min([ub, 15*y1_opt + 18*y2_opt + dsp.objVal])\n    print(f'lb={lb}, ub={ub}')\nelif dsp.Status == GRB.UNBOUNDED:\n    # add feasibility cut\n    pass\nelse:\n    pass\n\noptimal obj = 1200.00\nu1 = 4.00\nu2 = 0.00\nlb=0.0, ub=1200.0\n\n\nWe see that the dual subproblem has an optimal solution. Note that in line 15, the upper bound of the problem is updated.\nSince the optimal objective value of the subproblem turns out to be 1200 and is greater than \\(\\bar{g} = 0\\), which implies that an optimality cut is needed to make sure that the variable \\(g\\) in the restricted Benders master problem reflects this newly obtained information from the subproblem.\n\nrbmp.addConstr((300-4*y2-5*y2)*u1_opt \n               + (220-2*y1-3*y2)*u2_opt &lt;= g, \n               name='c3')\nrbmp.update()\nrbmp.optimize()\n\nif rbmp.status == GRB.OPTIMAL:\n    print(f'optimal solution found!')\n    \n    y1_opt = y1.X\n    y2_opt = y2.X\n    g_opt = g.X\n    lb = np.max([lb, rbmp.objVal])\n    \n    print(f'optimal obj: {rbmp.objVal:.2f}')\n    print(f'y1 = {y1_opt:.2f}')\n    print(f'y2 = {y2_opt:.2f}')\n    print(f'g = {g_opt:.2f}')\n    print(f'lb={lb}, ub={ub}')\nelif rbmp.status == GRB.INFEASIBLE:\n    print(f'original problem is infeasible!')\n\noptimal solution found!\noptimal obj: 600.00\ny1 = 0.00\ny2 = 33.33\ng = 0.00\nlb=600.0, ub=1200.0\n\n\nNow we solve the subproblem again with the newly obtained solution \\((\\bar{y_1}, \\bar{y_2}, \\bar{g}) = (0, 33.33, 0)\\).\n\ndsp.setObjective((300 - 4*y1_opt - 5*y2_opt) * u1 \n                 + (220 - 2*y1_opt - 3*y2_opt) * u2, \n                 GRB.MAXIMIZE)\ndsp.update()\ndsp.optimize()\n\nif dsp.status == GRB.OPTIMAL:\n    u1_opt = u1.X\n    u2_opt = u2.X\n    \n    print(f'optimal obj = {dsp.objVal:.2f}')\n    print(f'u1 = {u1_opt:.2f}')\n    print(f'u2 = {u2_opt:.2f}')\n    ub = np.min([ub, 15*y1_opt + 18*y2_opt + dsp.objVal])\n    print(f'lb={lb}, ub={ub}')\nelif dsp.status == GRB.UNBOUNDED:\n    print(f'dual subproblem is unbounded!')\n\noptimal obj = 533.33\nu1 = 4.00\nu2 = 0.00\nlb=600.0, ub=1133.3333333333333\n\n\nSince the optimal objective value of the subproblem, 533.33, is still bigger than \\(\\bar{g} = 0\\), an optimality cut is needed. In the below code snippet, we add the new cut and solve the restricted Benders master problem again.\n\nrbmp.addConstr((300 - 4*y1 - 5*y2) * u1_opt + (220 - 2*y1 - 3*y2) * u2_opt &lt;= g, name='c3')\nrbmp.update()\nrbmp.optimize()\n\nif rbmp.status == GRB.OPTIMAL:\n    print(f'optimal solution found!')\n    \n    y1_opt = y1.X\n    y2_opt = y2.X\n    g_opt = g.X\n    lb = np.max([lb, rbmp.objVal])\n    \n    print(f'optimal obj: {rbmp.objVal:.2f}')\n    print(f'y1 = {y1_opt:.2f}')\n    print(f'y2 = {y2_opt:.2f}')\n    print(f'g = {g_opt:.2f}')\n    print(f'lb={lb}, ub={ub}')\nelif rbmp.status == GRB.INFEASIBLE:\n    print(f'original problem is infeasible!')\n\noptimal solution found!\noptimal obj: 1080.00\ny1 = 0.00\ny2 = 60.00\ng = 0.00\nlb=1080.0, ub=1133.3333333333333\n\n\nNote that a new lower bound is obtained after solving the master problem. Since there is still a large gap between the lower bound and upper bound, we continue solving the subproblem.\n\ndsp.setObjective((300 - 4*y1_opt - 5*y2_opt) * u1 + (220 - 2*y1_opt - 3*y2_opt) * u2, GRB.MAXIMIZE)\ndsp.update()\ndsp.optimize()\n\nif dsp.status == GRB.OPTIMAL:\n    u1_opt = u1.X\n    u2_opt = u2.X\n    \n    print(f'optimal obj = {dsp.objVal:.2f}')\n    print(f'u1 = {u1_opt:.2f}')\n    print(f'u2 = {u2_opt:.2f}')\n    ub = np.min([ub, 15*y1_opt + 18*y2_opt + dsp.objVal])\n    print(f'lb={lb}, ub={ub}')\nelif dsp.status == GRB.UNBOUNDED:\n    print(f'dual subproblem is unbounded!')\n\noptimal obj = 80.00\nu1 = 0.00\nu2 = 2.00\nlb=1080.0, ub=1133.3333333333333\n\n\nNow the upper bound is reduced to 1133.33, but the subproblem optimal solution is still bigger than the value of \\(\\bar{g} = 0\\).\n\nrbmp.addConstr((300 - 4*y1 - 5*y2) * u1_opt + (220 - 2*y1 - 3*y2) * u2_opt &lt;= g, name='c3')\nrbmp.update()\nrbmp.optimize()\n\nif rbmp.status == GRB.OPTIMAL:\n    print(f'optimal solution found!')\n    \n    y1_opt = y1.X\n    y2_opt = y2.X\n    g_opt = g.X\n    lb = np.max([lb, rbmp.objVal])\n    \n    print(f'optimal obj: {rbmp.objVal:.2f}')\n    print(f'y1 = {y1_opt:.2f}')\n    print(f'y2 = {y2_opt:.2f}')\n    print(f'g = {g_opt:.2f}')\n    print(f'lb={lb}, ub={ub}')\nelif rbmp.status == GRB.INFEASIBLE:\n    print(f'original problem is infeasible!')\n\noptimal solution found!\noptimal obj: 1091.43\ny1 = 0.00\ny2 = 54.29\ng = 114.29\nlb=1091.4285714285713, ub=1133.3333333333333\n\n\n\ndsp.setObjective((300 - 4*y1_opt - 5*y2_opt) * u1 + (220 - 2*y1_opt - 3*y2_opt) * u2, GRB.MAXIMIZE)\ndsp.update()\ndsp.optimize()\n\nif dsp.status == GRB.OPTIMAL:\n    u1_opt = u1.X\n    u2_opt = u2.X\n    \n    print(f'optimal obj = {dsp.objVal:.2f}')\n    print(f'u1 = {u1_opt:.2f}')\n    print(f'u2 = {u2_opt:.2f}')\n    ub = np.min([ub, 15*y1_opt + 18*y2_opt + dsp.objVal])\n    print(f'lb={lb}, ub={ub}')\nelif dsp.status == GRB.UNBOUNDED:\n    print(f'dual subproblem is unbounded!')\n\noptimal obj = 114.29\nu1 = 0.00\nu2 = 2.00\nlb=1091.4285714285713, ub=1091.4285714285713\n\n\nNow the gap between the lower bound and upper bound is reduced to 0, the problem completes.\n\n\n4.2.4 Putting it together\nCertainly we don’t want to manually control the interaction between the master problem and subproblem to find the optimal solution. Therefore, in this section, we will put every together to come up with a control flow to help us identify the optimal solution automatically.\n\nfrom enum import Enum\n\nclass OptStatus(Enum):\n    OPTIMAL = 0\n    UNBOUNDED = 1\n    INFEASIBLE = 2\n    ERROR = 3\n\n\nclass MasterSolver:\n    \n    def __init__(self):\n        self._env = gp.Env('MasterProbEnv')\n        self._model = gp.Model(env=env, name='RBMP')\n        \n        # create decision variables\n        self._y1 = self._model.addVar(vtype=GRB.CONTINUOUS, lb=0, name='y1')\n        self._y2 = self._model.addVar(vtype=GRB.CONTINUOUS, lb=0, name='y2')\n        self._g = self._model.addVar(vtype=GRB.CONTINUOUS, lb=0, name='g')\n\n        # create objective\n        self._model.setObjective(15*self._y1 + 18*self._y2 + self._g, GRB.MINIMIZE)\n        \n        self._opt_obj = None\n        self._opt_y1 = None\n        self._opt_y2 = None\n        self._opt_g = None\n        \n    def solve(self) -&gt; OptStatus:\n        self._model.optimize()\n        \n        opt_status = None\n        if self._model.status == GRB.OPTIMAL:\n            opt_status = OptStatus.OPTIMAL\n            self._opt_obj = self._model.objVal\n            self._opt_y1 = self._y1.X\n            self._opt_y2 = self._y2.X\n            self._opt_g = self._g.X\n        elif self._model.status == GRB.INFEASIBLE:\n            opt_status = OptStatus.INFEASIBLE\n        else:\n            opt_status = OptStatus.ERROR\n            \n        return opt_status\n    \n    def add_feasibility_cut(self) -&gt; None:\n        \n        pass\n    \n    def add_optimality_cut(self) -&gt; None:\n        \n        pass\n    \n    def clean_up(self):\n        self._env.dispose()\n        self._model.dispose()\n        \n    @property\n    def opt_obj(self):\n        return self._opt_obj\n    \n    @property\n    def opt_y1(self):\n        return self._y1\n    \n    @property\n    def opt_y2(self):\n        return self._y2\n    \n    @property\n    def opt_g(self):\n        return self._g\n\n\nclass DualSubprobSolver:\n    \n    def __init__(self):\n        \n        pass\n    \n    def solve(self):\n        \n        pass\n    \n    def update_objective(self):\n        \n        pass\n    \n    def clean_up(self):\n        self._env.dispose()\n        self._model.dispose()\n\n\nclass BendersDecomposition:\n    \n    def __init__(self, master_solver, dual_subprob_solver):\n        self._master_solver = master_solver\n        self._dual_subprob_solver = dual_subprob_solver\n        \n    \n    def optimize(self) -&gt; OptStatus:\n        eps = 1.0e-5\n        lb = -np.inf\n        ub = np.inf\n        \n        while True:\n            # solve master problem\n            master_status = self._master_solver.solve()\n            if master_status == OptStatus.INFEASIBLE:\n                return OptStatus.INFEASIBLE\n            \n            # update lower bound\n            lb = np.max([lb, self._master_solver.opt_obj])\n            \n            # solve subproblem\n            self._dual_subprob_solver.solve()\n            \n            # update upper bound\n            \n            if ub - lb &lt;= eps:\n                break\n\n\n\n4.2.5 A generic solver\n\n\n4.2.6 Implementation with callbacks"
  }
]